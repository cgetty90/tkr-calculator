<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>The Krew • TKR Arena Scoring</title>
  <style>
    :root{
      --bg:#07020f;
      --text:#fff7fb;
      --muted: rgba(255,247,251,.72);

      --card: rgba(18,6,28,.88);
      --card2: rgba(12,4,20,.92);

      --accent:#ff3bd4;          /* neon magenta */
      --accent2:#ffb000;         /* ember gold */
      --border: rgba(255, 59, 212, .22);
      --border2: rgba(255, 59, 212, .55);
      --glow: rgba(255, 59, 212, .16);

      --btn: rgba(255, 59, 212, .14);
      --btnHover: rgba(255, 59, 212, .22);

      --pillBg: rgba(12,4,20,.96);
    }

    *{ box-sizing:border-box; }

    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:var(--bg);
      color:var(--text);
      margin:0;
      padding:20px;
    }

    h1{ margin:0 0 14px 0; letter-spacing:.3px; }
    h3{ margin:0 0 10px 0; }

    .card{
      overflow: visible;

      background:var(--card);
      border:1px solid var(--border);
      border-radius:12px;
      padding:12px;
      margin-bottom:14px;
      box-shadow: 0 0 0 1px var(--glow), 0 8px 30px rgba(0,0,0,.45);
      backdrop-filter: blur(6px);
    }

    label{
      font-size:12px;
      color:var(--muted);
      display:block;
      margin-bottom:4px;
    }

    input, select, button{
      width:100%;
      padding:7px;
      border-radius:10px;
      border:1px solid var(--border2);
      background:var(--card2);
      color:var(--text);
      box-shadow: 0 0 0 1px rgba(176, 80, 255, .10), 0 0 18px rgba(176, 80, 255, .10);
      outline:none;
      font-size:14px;
    }

    input:focus, select:focus{
      box-shadow: 0 0 0 2px rgba(176, 80, 255, .35), 0 0 26px rgba(176, 80, 255, .18);
    }

    button{
      cursor:pointer;
      background:var(--btn);
      border:1px solid rgba(176,80,255,.85);
      color:var(--text);
      box-shadow: 0 0 18px rgba(176,80,255,.16);
    }
    button:hover{
      background:var(--btnHover);
      box-shadow: 0 0 26px rgba(176,80,255,.22);
    }

    .grid{ display:grid; gap:16px; }
    .grid-4{ grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); }
    .grid-2{ grid-template-columns: 1fr 1fr; }
    @media (max-width:900px){
      .grid-2{ grid-template-columns: 1fr; }
    }

    .pill{
      display:inline-block;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid var(--border2);
      background:var(--pillBg);
      font-size:12px;
      margin-right:5px;
      margin-top:5px;
    }

    .muted{ color:var(--muted); font-size:12px; }

    .row{
      display:flex;
      gap:16px;
      align-items:end;
      flex-wrap:wrap;
    }
    .row > *{
      flex: 1;
      min-width: 240px;
    }

    .gameRow{
      border:1px solid var(--border);
      border-radius:14px;
      padding:10px;
      margin-bottom:10px;
      background:var(--card2);
      box-shadow: 0 0 0 1px rgba(176,80,255,.18), 0 0 22px rgba(176,80,255,.10);
    }

    .gameHead{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .gameHead strong{ font-size:14px; }
    .inlineBtn{ width:auto; padding:7px 10px; min-width: 110px; }

    /* Smaller player search boxes */
    .playerInput{
      padding:5px 8px;
      font-size:13px;
      border-radius:10px;
    }

    /* Autocomplete dropdown */
    .playerWrap{ position:relative; }
    .suggestions{
      position:absolute;
      top:calc(100% + 6px);
      left:0; right:0;
      max-height:220px;
      overflow:auto;
      background:var(--card2);
      border:1px solid var(--border2);
      border-radius:12px;
      z-index:20;
      display:none;
      box-shadow: 0 0 0 1px rgba(176,80,255,.14), 0 16px 40px rgba(0,0,0,.55);
    }
    .suggestionItem{
      padding:8px 10px;
      cursor:pointer;
      border-bottom:1px solid rgba(176,80,255,.18);
      font-size:13px;
      line-height:1.2;
    }
    .suggestionItem:last-child{ border-bottom:none; }
    .suggestionItem:hover, .suggestionItem.active{
      background: rgba(176, 80, 255, .14);
    }
    .suggestionMeta{ color: var(--muted); font-size:12px; margin-left:6px; }


    /* Mobile: suggestions render as fixed overlay above everything */
    .suggestions.fixed{
      position: fixed !important;
      left: 12px !important;
      right: auto !important;
      top: 0;
      width: calc(100vw - 24px) !important;
      max-height: 45vh !important;
      overflow:auto;
      z-index: 99999 !important;
      pointer-events: auto;
    }

    .spacer8{ height:8px; }
    .spacer10{ height:10px; }
  
/* === Arena Energy Theme === */

/* Animated arena glow */
body::before{
  content:"";
  position:fixed;
  inset:-30%;
  background:
    radial-gradient(circle at 20% 15%, rgba(255,59,212,.12), transparent 40%),
    radial-gradient(circle at 80% 85%, rgba(255,176,0,.10), transparent 45%),
    radial-gradient(circle at 60% 30%, rgba(255,59,212,.06), transparent 50%);
  filter: blur(2px);
  pointer-events:none;
  z-index:-2;
  animation: arenaDrift 18s ease-in-out infinite;
}
@keyframes arenaDrift{
  0%,100%{ transform: translate3d(0,0,0) scale(1); }
  50%{ transform: translate3d(-2%,1%,0) scale(1.02); }
}

/* Subtle scanlines */
body::after{
  content:"";
  position:fixed;
  inset:0;
  background: repeating-linear-gradient(
    to bottom,
    rgba(255,255,255,.03) 0px,
    rgba(255,255,255,.03) 1px,
    transparent 3px,
    transparent 6px
  );
  opacity:.07;
  mix-blend-mode: overlay;
  pointer-events:none;
  z-index:-1;
}

/* Cards feel like panels */
.card{
  background: linear-gradient(180deg, rgba(10,12,22,.92), rgba(7,9,18,.86));
  border: 1px solid rgba(255,59,212,.18);
  box-shadow:
    0 0 0 1px rgba(255,59,212,.10),
    0 18px 50px rgba(0,0,0,.62);
  position:relative;
  overflow:visible;
}
.card::before{
  content:"";
  position:absolute;
  inset:-2px;
  background: linear-gradient(90deg, rgba(255,59,212,.0), rgba(255,59,212,.10), rgba(255,176,0,.08), rgba(255,59,212,.0));
  opacity:.55;
  transform: translateX(-60%);
  animation: sheen 10s linear infinite;
  pointer-events:none;
}
@keyframes sheen{
  0%{ transform: translateX(-60%); }
  100%{ transform: translateX(60%); }
}

/* Headings */
h1{
  text-transform: uppercase;
  letter-spacing: .6px;
  text-shadow: 0 0 22px rgba(255,59,212,.18);
}
h3{
  text-transform: uppercase;
  letter-spacing:.4px;
}

/* Inputs: less border, more focus energy */
input, select{
  border: 1px solid rgba(255,59,212,.26);
  box-shadow: 0 0 10px rgba(255,59,212,.06);
}
input:focus, select:focus{
  border-color: rgba(255,59,212,.65);
  box-shadow: 0 0 0 2px rgba(255,59,212,.22), 0 0 16px rgba(255,59,212,.14);
}

/* Buttons */
button{
  border:1px solid rgba(255,59,212,.60);
  box-shadow: 0 0 18px rgba(255,59,212,.10);
}
button:hover{
  box-shadow: 0 0 26px rgba(255,59,212,.18);
}

/* Pills */
.pill{
  border-color: rgba(255,59,212,.50);
  box-shadow: 0 0 14px rgba(255,59,212,.08);
}

/* Progress meter */
.meterWrap{
  margin-top:10px;
  padding:10px;
  border-radius:14px;
  border:1px solid rgba(255,59,212,.22);
  background: linear-gradient(180deg, rgba(7,9,18,.92), rgba(6,7,14,.92));
  box-shadow: 0 0 18px rgba(255,59,212,.08);
}
.meterTop{
  display:flex;
  gap:10px;
  align-items:center;
  justify-content:space-between;
  flex-wrap:wrap;
}
.meterBar{
  height:12px;
  border-radius:999px;
  background: rgba(255,255,255,.06);
  border:1px solid rgba(255,59,212,.18);
  overflow:hidden;
}
.meterFill{
  height:100%;
  width:0%;
  border-radius:999px;
  background: linear-gradient(90deg, rgba(255,59,212,.95), rgba(255,176,0,.75));
  box-shadow: 0 0 22px rgba(255,59,212,.18);
  transition: width .35s ease;
}
.meterMeta{
  font-size:12px;
  color: var(--muted);
}

/* Game heat + counted */
.gameRow{
  border-color: rgba(255,255,255,.10);
}
.gameRow.counted{
  border-color: rgba(255,59,212,.55);
  box-shadow: 0 0 0 1px rgba(255,59,212,.14), 0 0 22px rgba(255,59,212,.10);
}
.gameRow.game-hot{
  border-color: rgba(255,59,212,.75) !important;
  box-shadow: 0 0 0 1px rgba(255,59,212,.18), 0 0 28px rgba(255,59,212,.14);
}
.gameRow.game-mid{
  border-color: rgba(255,59,212,.40) !important;
}
.gameRow.game-low{
  border-color: rgba(255,255,255,.12) !important;
}
.badge{
  display:inline-block;
  margin-left:8px;
  padding:3px 8px;
  border-radius:999px;
  font-size:12px;
  border:1px solid rgba(255,59,212,.45);
  background: rgba(7,9,18,.92);
  color: var(--text);
}
.badge.top{
  border-color: rgba(255,59,212,.70);
  box-shadow: 0 0 18px rgba(255,59,212,.12);
}


/* Header accent bar */
h3{
  position:relative;
  padding-bottom:8px;
}
h3::after{
  content:"";
  position:absolute;
  left:0;
  bottom:0;
  width:160px;
  height:3px;
  border-radius:999px;
  background: linear-gradient(90deg, rgba(255,59,212,.9), rgba(255,176,0,.85));
  box-shadow: 0 0 18px rgba(255,59,212,.14);
}
h1{
  background: linear-gradient(90deg, rgba(255,59,212,1), rgba(255,176,0,1));
  -webkit-background-clip: text;
  background-clip:text;
  color: transparent;
  text-shadow:none;
}


    /* (datalist doesn't render, but kept for JS compatibility) */
</style>
</head>
<body>
<form autocomplete="off">

<h1>THE KREW • TKR SCORING</h1>
<div class="muted" style="margin:-6px 0 14px 0;"></div>

<div class="card">
  <h3>SQUAD BUILDER</h3>

  <datalist id="playersList"></datalist>

  

  <div class="grid grid-4">
    <div class="playerWrap">
      <label>Player 1</label>
      <input class="playerInput" id="p1" placeholder="Type a name (or NONE)" autocomplete="off" autocapitalize="off" spellcheck="false"/>
      <div class="suggestions" id="sug-p1"></div>
    </div>
    <div class="playerWrap">
      <label>Player 2</label>
      <input class="playerInput" id="p2" placeholder="Type a name (or NONE)" autocomplete="off" autocapitalize="off" spellcheck="false"/>
      <div class="suggestions" id="sug-p2"></div>
    </div>
    <div class="playerWrap">
      <label>Player 3</label>
      <input class="playerInput" id="p3" placeholder="Type a name (or NONE)" autocomplete="off" autocapitalize="off" spellcheck="false"/>
      <div class="suggestions" id="sug-p3"></div>
    </div>
    <div class="playerWrap">
      <label>Player 4</label>
      <input class="playerInput" id="p4" placeholder="Type a name (or NONE)" autocomplete="off" autocapitalize="off" spellcheck="false"/>
      <div class="suggestions" id="sug-p4"></div>
    </div>
  </div>

  <div style="margin-top:10px">
    <span class="pill">Squad Rank: <b id="teamRank">–</b></span>
    <span class="pill">Active Players: <b id="realPlayers">0</b></span>
    <span class="pill">Rank Divisor (÷10): <b id="divisor">–</b></span>
  </div>

  </div>
<div class="card">
  <h3>KILL TARGETS</h3>

  <div class="grid grid-2" style="margin-bottom:10px;">
    <div>
      <label>Assumed placement</label>
      <!-- Static fallback options (JS also fills these) -->
      <select id="assumedPlacement">
        <option value="1st">1st</option>
        <option value="2nd-3rd">2nd–3rd</option>
        <option value="4th-5th">4th–5th</option>
        <option value="6th-10th">6th–10th</option>
        <option value="11th+">11th+</option>
      </select>

      <div class="spacer10"></div>
      <label>Milestones (+1 each)</label>
      <input id="milestonesLabel" disabled value="60,70,75,80,85,95,100"/>
    </div>

    <div>
      <label>Target total score (best 4 games)</label>
      <input id="targetTotal" type="number" min="0" step="0.01" value="180"/>
      <div class="muted" style="margin-top:6px;">
        Counted games: <b>best 4</b>. Max points/game = <b>45</b>.
      </div>
    </div>
  </div>

  <div id="killsNeeded45" style="margin-bottom:10px;">Select players to calculate</div>
  <div id="killsNeededTarget">—</div>
</div>

<div class="card">
  <h3>MATCH LOG</h3>

  <div id="games" style="margin-top:10px;"></div>

  <div style="margin-top:10px">
    <span class="pill">Best 4 Total: <b id="best4Total">0.00</b></span>
    <span class="pill">Remaining Possible: <b id="remainingPossible">180.00</b></span>
    <span class="pill">Matches Logged: <b id="gamesEntered">0</b></span>
  </div>

  <div class="meterWrap" id="meterWrap">
    <div class="meterTop">
      <div class="meterMeta"><b>Target Progress</b> — best 4 vs target</div>
      <div class="meterMeta">Best 4: <b id="meterBest4">0.00</b> / Target: <b id="meterTarget">180.00</b></div>
    </div>
    <div class="spacer8"></div>
    <div class="meterBar"><div class="meterFill" id="meterFill"></div></div>
  </div>

  <div class="spacer8"></div>

  <div class="muted" style="margin-top:8px;">
    Remaining Possible = (4 × 45) − (best-4 total). Games are sorted by points (highest first).
  </div>
  <div class="muted" style="margin-top:6px;">
    Saved on this device for <b>24 hours</b>.
  </div>

  <div class="spacer10"></div>
  <!-- Buttons moved to bottom -->
  <div class="row">
    <button id="addGameBtn" type="button">Add Game</button>
    <button id="resetBtn" type="button" title="Resets players, games, and target score">Reset</button>
  </div>
</div>


<div class="card" id="replacementCard" style="display:none;">
  <h3>REPLACEMENT CALCULATOR</h3>
  <div class="muted" style="margin-top:6px;">
    This section only appears once you’ve logged at least <b>4</b> matches.
  </div>

  <div class="spacer10"></div>

  <div class="grid grid-2">
    <div class="meterWrap">
      <div class="meterMeta"><b>Status</b></div>
      <div class="spacer8"></div>
      <div id="replaceSummary" class="muted">—</div>
    </div>

    <div class="meterWrap">
      <div class="meterMeta"><b>What to do next</b></div>
      <div class="spacer8"></div>
      <div id="replacePlan" class="muted">—</div>
    </div>
  </div>
</div>


<script>
const COUNTED_GAMES = 4;
const MAX_POINTS = 45;

// Local save (per device)
const STORAGE_KEY = "tkr_calc_state_all_v1";
const TTL_MS = 24 * 60 * 60 * 1000; // 24 hours

// Device detection for dropdown behavior (Samsung Internet friendly)
const IS_MOBILE = (
  (window.matchMedia && window.matchMedia("(pointer: coarse)").matches) ||
  ("ontouchstart" in window) ||
  (navigator.maxTouchPoints > 0)
);
let selectingSuggestion = false;

// Placement multipliers (4-player baseline). Trio-quad (3 real players) adds +0.15
const PLACEMENTS = [
  { key: "1st",      label: "1st",      base: 2.25 },
  { key: "2nd-3rd",  label: "2nd–3rd",  base: 1.50 },
  { key: "4th-5th",  label: "4th–5th",  base: 1.25 },
  { key: "6th-10th", label: "6th–10th", base: 1.00 },
  { key: "11th+",    label: "11th+",    base: 0.75 },
];

// Milestones (+1 each)
const MILESTONES = [60,70,75,80,85,95,100];

let rankings = [];
let rankByNameLower = new Map(); // lower(name) -> rank

// Games: {id, killsStr, killsInt, placement, points}
let games = [];
let gameNodes = new Map(); // id -> element
let nextGameId = 1;

// ===== small helpers =====
function nowMs(){ return Date.now(); }
function escapeHtml(str){
  return String(str).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#039;");
}
function unescapeHtml(str){
  const t = document.createElement("textarea");
  t.innerHTML = str;
  return t.value;
}
function parseCSVLine(line){
  const out = [];
  let cur = "";
  let inQ = false;
  for(let i=0;i<line.length;i++){
    const ch = line[i];
    if(ch === '"'){
      if(inQ && line[i+1] === '"'){ cur += '"'; i++; }
      else inQ = !inQ;
    }else if(ch === ',' && !inQ){
      out.push(cur); cur = "";
    }else cur += ch;
  }
  out.push(cur);
  return out.map(s => s.trim());
}

// ===== persistence =====
function saveState(){
  try{
    const state = {
      savedAt: nowMs(),
      team: {
        p1: document.getElementById("p1").value || "",
        p2: document.getElementById("p2").value || "",
        p3: document.getElementById("p3").value || "",
        p4: document.getElementById("p4").value || ""
      },
      settings: {
        assumedPlacement: document.getElementById("assumedPlacement").value || "1st",
        targetTotal: document.getElementById("targetTotal").value || ""
      },
      games: games.map(g => ({
        id: g.id,
        killsStr: g.killsStr ?? "",
        killsInt: (typeof g.killsInt === "number" ? g.killsInt : null),
        placement: g.placement || "1st"
      })),
      nextGameId
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  }catch(e){}
}

function loadState(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return false;
    const state = JSON.parse(raw);
    const age = nowMs() - (state.savedAt || 0);
    if(!isFinite(age) || age > TTL_MS){
      localStorage.removeItem(STORAGE_KEY);
      return false;
    }

    if(state.settings){
      if(state.settings.assumedPlacement) document.getElementById("assumedPlacement").value = state.settings.assumedPlacement;
      if(state.settings.targetTotal !== undefined) document.getElementById("targetTotal").value = state.settings.targetTotal;
    }

    if(state.team){
      ["p1","p2","p3","p4"].forEach(k=>{
        if(state.team[k] !== undefined) document.getElementById(k).value = state.team[k];
      });
    }

    // games
    games = [];
    gameNodes.forEach(n => n.remove());
    gameNodes.clear();

    nextGameId = (typeof state.nextGameId === "number" && state.nextGameId > 0) ? state.nextGameId : 1;

    if(Array.isArray(state.games)){
      state.games.forEach(sg=>{
        const id = (typeof sg.id === "number" && sg.id > 0) ? sg.id : nextGameId++;
        const g = {
          id,
          killsStr: (sg.killsStr ?? ""),
          killsInt: (typeof sg.killsInt === "number" ? sg.killsInt : null),
          placement: sg.placement || "1st",
          points: 0
        };
        games.push(g);
        const node = createGameNode(g);
        gameNodes.set(id, node);
        document.getElementById("games").appendChild(node);

        const killsEl = node.querySelector(`#kills-${id}`);
        if(killsEl) killsEl.value = g.killsStr || "";
        const placeEl = node.querySelector(`#place-${id}`);
        if(placeEl) placeEl.value = g.placement;
      });

      const maxId = games.reduce((m,g)=>Math.max(m,g.id), 0);
      if(nextGameId <= maxId) nextGameId = maxId + 1;
    }

    return true;
  }catch(e){
    return false;
  }
}

// ===== scoring =====
function milestonePoints(kills){
  const k = (typeof kills === "number" && isFinite(kills)) ? kills : 0;
  return MILESTONES.filter(m => k >= m).length;
}

function placementMulti(placementKey, realPlayers){
  const p = PLACEMENTS.find(x => x.key === placementKey) || PLACEMENTS[0];
  return p.base + ((realPlayers === 3) ? 0.15 : 0.0);
}

function gamePointsFromKills(kills, placementKey, teamRank, realPlayers){
  const k = (typeof kills === "number" && isFinite(kills)) ? kills : 0;
  const div = teamRank * 0.1;
  const multi = placementMulti(placementKey, realPlayers);
  const raw = (k * multi / div) + milestonePoints(k);
  return Math.min(MAX_POINTS, raw);
}

function minKillsForTarget(targetPoints, placementKey, teamRank, realPlayers){
  if(targetPoints <= 0) return 0;
  if(targetPoints > MAX_POINTS) return null;
  for(let kills=0; kills<=5000; kills++){
    const pts = gamePointsFromKills(kills, placementKey, teamRank, realPlayers);
    if(pts >= targetPoints) return kills;
  }
  return null;
}

// ===== CSV loading =====
async function loadCSV(){
  const url = "rankings.csv?ts=" + Date.now();
  const text = await fetch(url, { cache: "no-store" }).then(r=>r.text());

  const lines = text.replace(/\r/g,"").split("\n").filter(l => l.trim().length);
  if(!lines.length) throw new Error("rankings.csv is empty");

  const headers = parseCSVLine(lines.shift()).map(h => h.toLowerCase());
  const nameIdx = headers.indexOf("name");
  const rankIdx = headers.indexOf("rank");
  if(nameIdx === -1 || rankIdx === -1) throw new Error("rankings.csv must have headers: name,rank");

  rankings = [];
  rankByNameLower = new Map();

  lines.forEach(l=>{
    const cols = parseCSVLine(l);
    const name = String(cols[nameIdx] ?? "").trim();
    const rank = parseFloat(String(cols[rankIdx] ?? "0").trim());
    if(!name) return;
    const r = isFinite(rank) ? rank : 0;
    rankings.push({ name, rank: r });
    rankByNameLower.set(name.toLowerCase(), r);
  });

  rankings.sort((a,b)=>a.name.localeCompare(b.name, undefined, { sensitivity:"base" }));

  buildDatalist();
  fillPlacements();      // reinforces options and keeps selection
  hookInputs();
  document.getElementById("milestonesLabel").value = MILESTONES.join(", ");

  loadState();
  updateTeam(true);
  recalc(true);
}

function buildDatalist(){
  const dl = document.getElementById("playersList");
  if(!dl) return;
  dl.innerHTML = "";
const none = document.createElement("option");
  none.value = "NONE";
  none.label = "NONE (0)";
  dl.appendChild(none);

  rankings.forEach(r=>{
    const opt = document.createElement("option");
    opt.value = r.name;
    opt.label = `${r.name} (${r.rank})`;
    dl.appendChild(opt);
  });
}

function fillPlacements(){
  const s = document.getElementById("assumedPlacement");
  const current = s.value || "1st";
  // If the select is empty (or user has static fallback), ensure options exist and set value
  if(!s.options || s.options.length === 0){
    PLACEMENTS.forEach(p=>{
      const o = document.createElement("option");
      o.value = p.key;
      o.textContent = p.label;
      s.appendChild(o);
    });
  }
  s.value = current;
  s.addEventListener("change", () => {
    updateTeam(true);
    saveState();
  });
}

// ===== Autocomplete dropdown =====
function getAllPlayerNames(){
  return ["NONE", ...rankings.map(r => r.name)];
}
function getRankForName(name){
  if(!name) return null;
  if(name.toLowerCase() === "none") return 0;
  const r = rankByNameLower.get(name.toLowerCase());
  return (typeof r === "number") ? r : null;
}
function showSuggestions(inputId){
  const input = document.getElementById(inputId);
  const box = document.getElementById("sug-" + inputId);
  if(!input || !box) return;

  const q = (input.value || "").trim().toLowerCase();
  const names = getAllPlayerNames();

  let matches = names.filter(n => n.toLowerCase().includes(q));
  matches.sort((a,b)=>{
    const al = a.toLowerCase(), bl = b.toLowerCase();
    const as = q && al.startsWith(q), bs = q && bl.startsWith(q);
    if(as !== bs) return as ? -1 : 1;
    return a.localeCompare(b, undefined, {sensitivity:"base"});
  });

  if(!q){
    const rest = rankings.map(r=>r.name).slice().sort((a,b)=>a.localeCompare(b, undefined, {sensitivity:"base"}));
    matches = ["NONE", ...rest];
  }

  matches = matches.slice(0, 12);

  if(matches.length === 0){
    box.style.display = "none";
    box.innerHTML = "";
    return;
  }

  box.innerHTML = matches.map((name, idx)=>{
    const rank = getRankForName(name);
    const meta = (rank === null) ? "" : `<span class="suggestionMeta">(${rank})</span>`;
    return `<div class="suggestionItem" data-name="${escapeHtml(name)}" data-idx="${idx}">${escapeHtml(name)} ${meta}</div>`;
  }).join("");

  // Mobile: lift dropdown above all cards and align near the input
  box.dataset.active = "-1";
  box.style.display = "block";
  if(IS_MOBILE){
    box.classList.add("fixed");
    const r = input.getBoundingClientRect();
    const pad = 12;
    const top = Math.min(window.innerHeight - 12, r.bottom + 8);
    box.style.top = top + "px";
    box.style.left = pad + "px";
    box.style.width = `calc(100vw - ${pad*2}px)`;
  }else{
    box.classList.remove("fixed");
    box.style.top = "";
    box.style.left = "";
    box.style.width = "";
  }

  // Event delegation: reliable on Samsung Internet (fires before blur)
  const pick = (target) => {
    const item = target && target.closest ? target.closest(".suggestionItem") : null;
    if(!item) return;
    selectingSuggestion = true;
    const name = item.getAttribute("data-name");
    input.value = unescapeHtml(name);
    hideSuggestions(inputId);
    updateTeam(true);
    saveState();
    setTimeout(()=> selectingSuggestion = false, 0);
  };
  box.onpointerdown = (e) => { e.preventDefault(); e.stopPropagation(); pick(e.target); };
  box.ontouchstart = (e) => { e.preventDefault(); e.stopPropagation(); pick(e.target); };

}
function hideSuggestions(inputId){
  const box = document.getElementById("sug-" + inputId);
  if(!box) return;
  box.style.display = "none";
  box.innerHTML = "";
  box.dataset.active = "-1";
  box.classList.remove("fixed");
  box.style.top = "";
  box.style.left = "";
  box.style.width = "";
}
function handleSuggestKeys(e, inputId){
  const box = document.getElementById("sug-" + inputId);
  const input = document.getElementById(inputId);
  if(!box || !input) return;

  const isOpen = box.style.display === "block";
  if(!isOpen && (e.key === "ArrowDown" || e.key === "ArrowUp")){
    showSuggestions(inputId);
    return;
  }
  if(!isOpen) return;

  const items = Array.from(box.querySelectorAll(".suggestionItem"));
  if(items.length === 0) return;

  let active = parseInt(box.dataset.active || "-1", 10);
  if(e.key === "ArrowDown"){
    e.preventDefault();
    active = Math.min(items.length - 1, active + 1);
  }else if(e.key === "ArrowUp"){
    e.preventDefault();
    active = Math.max(0, active - 1);
  }else if(e.key === "Enter"){
    if(active >= 0 && active < items.length){
      e.preventDefault();
      items[active].click();
    }
    return;
  }else if(e.key === "Escape"){
    hideSuggestions(inputId);
    return;
  }else{
    return;
  }

  items.forEach((it, i)=> it.classList.toggle("active", i === active));
  box.dataset.active = String(active);
  const it = items[active];
  if(it) it.scrollIntoView({block:"nearest"});
}

// ===== UI & interactions =====
function hookInputs(){
  window.addEventListener('scroll', () => { if(IS_MOBILE){ ['p1','p2','p3','p4'].forEach(hideSuggestions); } }, {passive:true});
  window.addEventListener('resize', () => { if(IS_MOBILE){ ['p1','p2','p3','p4'].forEach(hideSuggestions); } });

  // Player inputs
  ["p1","p2","p3","p4"].forEach(id=>{
    const el = document.getElementById(id);
    el.addEventListener("input", () => {
      showSuggestions(id);
      updateTeam(false);
    });
    el.addEventListener("focus", () => showSuggestions(id));
    el.addEventListener("keydown", (e) => handleSuggestKeys(e, id));
    el.addEventListener("change", () => updateTeam(true));
    el.addEventListener("blur", () => {
      // On mobile, tapping a suggestion blurs first — don’t hide immediately.
      setTimeout(() => { if(!selectingSuggestion) hideSuggestions(id); }, 350);
      updateTeam(true);
    });
  });

  document.getElementById("targetTotal").addEventListener("input", () => {
    const rankTxt = document.getElementById("teamRank").textContent;
    if(rankTxt !== "–"){
      calcKillsNeededBlocks(parseFloat(rankTxt), parseInt(document.getElementById("realPlayers").textContent || "0", 10));
      updateReplacementHelper();
    }
    saveState();
  });

  document.getElementById("addGameBtn").addEventListener("click", () => addGame());

  document.getElementById("resetBtn").addEventListener("click", () => {
    // Reset players + games + target score. Keep static rules/multipliers.
    ["p1","p2","p3","p4"].forEach(id => {
      const el = document.getElementById(id);
      if(el) el.value = "";
      hideSuggestions(id);
    });

    const tgt = document.getElementById("targetTotal");
    if(tgt) tgt.value = String(COUNTED_GAMES * MAX_POINTS);

    games = [];
    gameNodes.forEach(n => n.remove());
    gameNodes.clear();
    nextGameId = 1;

    saveState();
    updateTeam(true);
  });
}

function normalizeName(raw){
  let v = String(raw ?? "").trim();
  if(!v) return "";
  const idx = v.lastIndexOf(" (");
  if(idx > 0 && v.endsWith(")")) v = v.slice(0, idx).trim();
  return v;
}

function computeTeam(){
  const ids = ["p1","p2","p3","p4"];
  let teamRank = 0;
  let realPlayers = 0;

  ids.forEach(id=>{
    const typed = normalizeName(document.getElementById(id).value);
    if(!typed) return;
    if(typed.toLowerCase() === "none") return;

    const r = rankByNameLower.get(typed.toLowerCase());
    if(typeof r === "number"){
      teamRank += r;
      realPlayers += 1;
    }
  });

  return { teamRank, realPlayers };
}

function calcKillsNeededBlocks(teamRank, realPlayers){
  const placementKey = document.getElementById("assumedPlacement").value || "1st";
  const placementLabel = PLACEMENTS.find(p=>p.key===placementKey)?.label || placementKey;
  const multi = placementMulti(placementKey, realPlayers);
  const div = teamRank * 0.1;

  const k45 = minKillsForTarget(45, placementKey, teamRank, realPlayers);
  document.getElementById("killsNeeded45").innerHTML =
    `<b>${k45 ?? "—"}</b> kills needed for a <b>45-point</b> game as <b>${placementLabel}</b>.
     <div class="muted" style="margin-top:6px;">
       (Multiplier <b>${multi.toFixed(2)}</b>, divisor <b>${div.toFixed(2)}</b>, milestones included, capped at 45)
     </div>`;

  const targetTotal = parseFloat(document.getElementById("targetTotal").value || "0");
  const perGameTarget = targetTotal / COUNTED_GAMES;

  if(!isFinite(targetTotal) || targetTotal < 0){
    document.getElementById("killsNeededTarget").innerHTML = `<span class="muted">Enter a valid target total.</span>`;
    return;
  }
  if(perGameTarget > MAX_POINTS){
    document.getElementById("killsNeededTarget").innerHTML =
      `<span class="muted">Target total <b>${targetTotal.toFixed(2)}</b> implies <b>${perGameTarget.toFixed(2)}</b> points/game, but max is <b>45</b>.</span>`;
    return;
  }

  const kTarget = minKillsForTarget(perGameTarget, placementKey, teamRank, realPlayers);
  document.getElementById("killsNeededTarget").innerHTML =
    `<b>${kTarget ?? "—"}</b> kills/game to average <b>${perGameTarget.toFixed(2)}</b> points/game (target total <b>${targetTotal.toFixed(2)}</b>), as <b>${placementLabel}</b>.`;
}

function updateReplacementHelper(){
  const card = document.getElementById("replacementCard");
  const summaryEl = document.getElementById("replaceSummary");
  const planEl = document.getElementById("replacePlan");
  if(!card || !summaryEl || !planEl) return;

  // Only show once 4+ games are logged
  if(games.length < 4){
    card.style.display = "none";
    return;
  }
  card.style.display = "block";

  const rankTxt = document.getElementById("teamRank").textContent;
  const realPlayers = parseInt(document.getElementById("realPlayers").textContent || "0", 10);
  const targetTotal = parseFloat(document.getElementById("targetTotal").value || String(COUNTED_GAMES * MAX_POINTS));

  if(rankTxt === "–"){
    summaryEl.innerHTML = `<b>Select players</b> to calculate replacement requirements.`;
    planEl.textContent = "—";
    return;
  }
  if(!isFinite(targetTotal) || targetTotal < 0){
    summaryEl.innerHTML = `<b>Enter a valid target total</b>.`;
    planEl.textContent = "—";
    return;
  }

  const teamRank = parseFloat(rankTxt);
  const placementKey = document.getElementById("assumedPlacement").value || "1st";
  const placementLabel = PLACEMENTS.find(p=>p.key===placementKey)?.label || placementKey;

  const sorted = [...games].sort((a,b)=> (b.points - a.points) || (a.id - b.id));
  const best4 = sorted.slice(0, 4);
  const best4Total = best4.reduce((s,g)=>s+g.points, 0);

  // How many games need replacing? (how many of the best4 must improve to hit target)
  const gap = targetTotal - best4Total;
  let gamesToReplace = 0;
  if(gap <= 0){
    gamesToReplace = 0;
  }else if(gap <= 45){
    gamesToReplace = 1;
  }else if(gap <= 90){
    gamesToReplace = 2;
  }else if(gap <= 135){
    gamesToReplace = 3;
  }else{
    gamesToReplace = 4;
  }

  // Build a readable summary
  const fourth = best4[3];
  const fourthTxt = fourth
    ? `${fourth.points.toFixed(2)} pts • ${fourth.killsInt ?? 0} kills • ${PLACEMENTS.find(p=>p.key===fourth.placement)?.label || fourth.placement}`
    : "—";

  summaryEl.innerHTML =
    `Target: <b>${targetTotal.toFixed(2)}</b><br>` +
    `Current best 4 total: <b>${best4Total.toFixed(2)}</b><br>` +
    `4th best game: <b>${fourthTxt}</b><br>` +
    (gamesToReplace === 0
      ? `<span style="color:var(--text);"><b>✅ Target met.</b></span>`
      : `<b>${gamesToReplace}</b> game(s) likely need replacing to reach target.`);

  // Build the plan
  if(gamesToReplace === 0){
    planEl.innerHTML = `You’re good. If you want to improve, aim to replace your current 4th best game (<b>${fourth.points.toFixed(2)} pts</b>) with a higher score.`;
    return;
  }

  // Strategy:
  // If 1 game can close it: use best3 + needed
  // Else: best2 + 2 games split suggestions
  const best3 = sorted.slice(0, 3);
  const best3Total = best3.reduce((s,g)=>s+g.points, 0);
  const need1 = targetTotal - best3Total;

  if(need1 <= MAX_POINTS){
    const kills = minKillsForTarget(need1, placementKey, teamRank, realPlayers);
    const improve = Math.max(0, need1 - (fourth ? fourth.points : 0));
    planEl.innerHTML =
      `To hit the target, your <b>4th counted game</b> needs about <b>${need1.toFixed(2)} pts</b>.<br>` +
      `That’s roughly <b>${kills ?? "—"}</b> kills if you place <b>${placementLabel}</b>.<br>` +
      (fourth ? `That’s <b>+${improve.toFixed(2)} pts</b> better than your current 4th best.` : ``);
    return;
  }

  // Two-game replacement plan
  const best2 = sorted.slice(0, 2);
  const best2Total = best2.reduce((s,g)=>s+g.points, 0);
  const need2 = targetTotal - best2Total;

  if(need2 > 2 * MAX_POINTS){
    planEl.innerHTML =
      `Even replacing <b>2 games</b>, you’d need <b>${need2.toFixed(2)}</b> points across two games, but max is <b>90</b> (2×45).<br>` +
      `Try lowering the target or improving more than two games.`;
    return;
  }

  const even = need2 / 2;
  const evenKills = minKillsForTarget(even, placementKey, teamRank, realPlayers);

  const firstA = Math.min(MAX_POINTS, need2);
  const secondA = Math.max(0, need2 - firstA);
  const kA1 = minKillsForTarget(firstA, placementKey, teamRank, realPlayers);
  const kA2 = minKillsForTarget(secondA, placementKey, teamRank, realPlayers);

  planEl.innerHTML =
    `One game isn’t enough. You likely need to replace <b>2 games</b>.<br>` +
    `Total points needed across 2 games: <b>${need2.toFixed(2)}</b> (max 90).<br><br>` +
    `<b>Option A:</b> even split → <b>${even.toFixed(2)} pts</b> each ≈ <b>${evenKills ?? "—"}</b> kills/game as <b>${placementLabel}</b>.<br>` +
    `<b>Option B:</b> one big + cleanup → <b>${firstA.toFixed(2)} pts</b> then <b>${secondA.toFixed(2)} pts</b> ≈ <b>${kA1 ?? "—"}</b> kills then <b>${kA2 ?? "—"}</b> kills.`;
}

function updateTeam(forceSort){
  const { teamRank, realPlayers } = computeTeam();
  document.getElementById("realPlayers").textContent = String(realPlayers);

  if(teamRank <= 0){
    document.getElementById("teamRank").textContent = "–";
    document.getElementById("divisor").textContent = "–";
    document.getElementById("killsNeeded45").textContent = "Select players to calculate";
    document.getElementById("killsNeededTarget").textContent = "—";
    updateReplacementHelper();
    recalc(forceSort);
    saveState();
    return;
  }

  document.getElementById("teamRank").textContent = teamRank.toFixed(2);
  document.getElementById("divisor").textContent = (teamRank*0.1).toFixed(2);

  calcKillsNeededBlocks(teamRank, realPlayers);
  recalc(forceSort);
  updateReplacementHelper();
  saveState();
}

function addGame(){
  const id = nextGameId++;
  const g = { id, killsStr: "", killsInt: null, placement: "1st", points: 0 };
  games.push(g);

  const node = createGameNode(g);
  gameNodes.set(id, node);
  document.getElementById("games").appendChild(node);

  recalc(true);
  // Jump to the new game row
  try{ node.scrollIntoView({behavior:"smooth", block:"start"}); }catch(e){}
  updateReplacementHelper();
  saveState();
}

function createGameNode(g){
  const wrapper = document.createElement("div");
  wrapper.className = "gameRow";
  wrapper.dataset.gameId = String(g.id);

  wrapper.innerHTML = `
    <div class="gameHead">
      <strong id="title-${g.id}">Game</strong>
      <button class="inlineBtn" id="remove-${g.id}">Remove</button>
    </div>

    <div class="row" style="margin-top:10px;">
      <div>
        <label>Total team kills (combined)</label>
        <input type="number" min="0" placeholder="Enter kills" id="kills-${g.id}" value="">
      </div>
      <div>
        <label>Placement</label>
        <select id="place-${g.id}"></select>
      </div>
    </div>

    <div class="muted" style="margin-top:8px;">
      Milestone points: <b id="mile-${g.id}">0</b>
      &nbsp;|&nbsp; Game points: <b id="pts-${g.id}">0.00</b> (capped at 45)
    </div>
  `;

  const placeSel = wrapper.querySelector(`#place-${g.id}`);
  PLACEMENTS.forEach(p=>{
    const opt = document.createElement("option");
    opt.value = p.key;
    opt.textContent = p.label;
    placeSel.appendChild(opt);
  });
  placeSel.value = g.placement;

  wrapper.querySelector(`#remove-${g.id}`).addEventListener("click", () => {
    games = games.filter(x => x.id !== g.id);
    const node = gameNodes.get(g.id);
    if(node) node.remove();
    gameNodes.delete(g.id);
    recalc(true);
    updateReplacementHelper();
    saveState();
  });

  const killsInput = wrapper.querySelector(`#kills-${g.id}`);

  killsInput.addEventListener("input", (e) => {
    const val = String(e.target.value ?? "");
    g.killsStr = val;
    const t = val.trim();
    if(t === ""){
      g.killsInt = null;
    } else {
      const n = parseInt(t, 10);
      g.killsInt = (isFinite(n) ? Math.max(0, n) : null);
    }
    recalc(false);
    updateReplacementHelper();
    saveState();
  });

  killsInput.addEventListener("change", () => { recalc(true); updateReplacementHelper(); saveState(); });
  killsInput.addEventListener("blur", () => { recalc(true); updateReplacementHelper(); saveState(); });

  placeSel.addEventListener("change", (e) => {
    g.placement = e.target.value;
    recalc(true);
    updateReplacementHelper();
    saveState();
  });

  return wrapper;
}

function recalc(forceSort){
  const rankTxt = document.getElementById("teamRank").textContent;
  const realPlayers = parseInt(document.getElementById("realPlayers").textContent || "0", 10);

  let teamRank = null;
  if(rankTxt !== "–") teamRank = parseFloat(rankTxt);

  games.forEach(g=>{
    const kills = (typeof g.killsInt === "number") ? g.killsInt : 0;
    g.points = (teamRank && teamRank > 0) ? gamePointsFromKills(kills, g.placement, teamRank, realPlayers) : 0;

    const node = gameNodes.get(g.id);
    if(node){
      node.querySelector(`#mile-${g.id}`).textContent = String(milestonePoints(kills));
      node.querySelector(`#pts-${g.id}`).textContent = g.points.toFixed(2);
    }
  });

  const sortedByPts = [...games].sort((a,b) => (b.points - a.points) || (a.id - b.id));
  const best4 = sortedByPts.slice(0, COUNTED_GAMES);
  const best4Total = best4.reduce((s,g)=>s+g.points, 0);

  const maxTotal = COUNTED_GAMES * MAX_POINTS;
  const remaining = Math.max(0, maxTotal - best4Total);

  document.getElementById("best4Total").textContent = best4Total.toFixed(2);
  document.getElementById("remainingPossible").textContent = remaining.toFixed(2);
  document.getElementById("gamesEntered").textContent = String(games.length);
  // Mark counted (top 4) games + heat colouring
  const topIds = new Set(best4.map(g => g.id));
  sortedByPts.forEach((g) => {
    const node = gameNodes.get(g.id);
    if(!node) return;

    node.classList.toggle("counted", topIds.has(g.id));

    // Heat based on points
    node.classList.remove("game-hot","game-mid","game-low");
    if(g.points >= 44){
      node.classList.add("game-hot");
    }else if(g.points >= 30){
      node.classList.add("game-mid");
    }else{
      node.classList.add("game-low");
    }

    // Add/remove badge in title
    const title = node.querySelector(`#title-${g.id}`);
    if(title){
      // keep existing "Game (Rank X)" text, then badge
      title.querySelectorAll(".badge").forEach(b => b.remove());
      const badge = document.createElement("span");
      badge.className = "badge" + (topIds.has(g.id) ? " top" : "");
      badge.textContent = topIds.has(g.id) ? "COUNTED" : "EXTRA";
      title.appendChild(badge);
    }
  });

  // Update target progress meter
  const tgt = parseFloat(document.getElementById("targetTotal").value || String(COUNTED_GAMES * MAX_POINTS));
  const meterBest4 = document.getElementById("meterBest4");
  const meterTarget = document.getElementById("meterTarget");
  const meterFill = document.getElementById("meterFill");
  if(meterBest4) meterBest4.textContent = best4Total.toFixed(2);
  if(meterTarget) meterTarget.textContent = (isFinite(tgt) ? tgt.toFixed(2) : (COUNTED_GAMES * MAX_POINTS).toFixed(2));
  if(meterFill){
    const denom = (isFinite(tgt) && tgt > 0) ? tgt : (COUNTED_GAMES * MAX_POINTS);
    const pct = Math.max(0, Math.min(100, (best4Total / denom) * 100));
    meterFill.style.width = pct.toFixed(1) + "%";
  }


  if(forceSort){
    // preserve focus/caret if typing
    const active = document.activeElement;
    const activeInfo = active ? { id: active.id, start: active.selectionStart ?? null, end: active.selectionEnd ?? null } : null;

    const container = document.getElementById("games");
    sortedByPts.forEach((g, idx) => {
      const node = gameNodes.get(g.id);
      if(node) container.appendChild(node);
      const title = node ? node.querySelector(`#title-${g.id}`) : null;
      if(title) title.textContent = `Game (Rank ${idx+1})`;
    });

    if(activeInfo && activeInfo.id){
      const el = document.getElementById(activeInfo.id);
      if(el){
        el.focus({ preventScroll:true });
        if(typeof activeInfo.start === "number" && typeof activeInfo.end === "number"){
          try{ el.setSelectionRange(activeInfo.start, activeInfo.end); }catch(e){}
        }
      }
    }
  }
}

loadCSV().catch(e=>{
  alert(e.message);
});
</script>

</form>
</body>
</html>
