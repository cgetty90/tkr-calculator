<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>TKR 45-Point Calculator</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:#0b0f14; color:#e8eef6; margin:0; padding:20px;}
    h1 { margin-top:0; }
    .card { background:#111826; border:1px solid #1f2a3a; border-radius:12px; padding:14px; margin-bottom:14px;}
    label { font-size:12px; opacity:.8; display:block; margin-bottom:4px;}
    input, select, button {
      width:100%; padding:8px; border-radius:8px;
      border:1px solid #243248; background:#0c1421; color:#e8eef6;
    }
    button { cursor:pointer; background:#13243d; }
    button:hover { background:#173056; }
    .grid { display:grid; gap:12px; }
    .grid-4 { grid-template-columns:1fr 1fr 1fr 1fr; }
    .grid-2 { grid-template-columns:1fr 1fr; }
    @media (max-width:900px){ .grid-4{grid-template-columns:1fr;} .grid-2{grid-template-columns:1fr;} }
    .pill { display:inline-block; padding:4px 8px; border-radius:999px; border:1px solid #2a3b55; background:#0c1421; font-size:12px; margin-right:6px; margin-top:6px;}
    .muted { opacity:.85; font-size:12px; }
    .row { display:flex; gap:10px; align-items:end; }
    .row > * { flex: 1; }
    .gameRow { border:1px solid #1f2a3a; border-radius:12px; padding:12px; margin-bottom:10px; background:#0c1421; }
    .gameHead { display:flex; justify-content:space-between; align-items:center; gap:10px; }
    .gameHead strong { font-size:14px; }
    .inlineBtn { width:auto; padding:8px 10px; }
    .right { text-align:right; }
  
    .playerWrap{ position:relative; }
    .suggestions{
      position:absolute;
      top:calc(100% + 6px);
      left:0; right:0;
      max-height:220px;
      overflow:auto;
      background:var(--card2);
      border:1px solid var(--border2);
      border-radius:12px;
      z-index:999;
      display:none;
      box-shadow: 0 0 0 1px rgba(176,80,255,.14), 0 16px 40px rgba(0,0,0,.55);
    }
    .suggestionItem{
      padding:8px 10px;
      cursor:pointer;
      border-bottom:1px solid rgba(176,80,255,.18);
      font-size:13px;
      line-height:1.2;
    }
    .suggestionItem:last-child{ border-bottom:none; }
    .suggestionItem:hover, .suggestionItem.active{
      background: rgba(176, 80, 255, .14);
    }
    .suggestionMeta{ color: var(--muted); font-size:12px; margin-left:6px; }
    ""</style>
</head>
<body>

<h1>TKR – 45 Point Calculator</h1>

<div class="card">
  <h3 style="margin-top:0;">Team Selection (4 slots)</h3>

  <datalist id="playersList"></datalist>

  <div class="grid grid-4">
    <div><label>Player 1</label><input id="p1" list="playersList" placeholder="Type a name (or NONE)"/></div>
    <div><label>Player 2</label><input id="p2" list="playersList" placeholder="Type a name (or NONE)"/></div>
    <div><label>Player 3</label><input id="p3" list="playersList" placeholder="Type a name (or NONE)"/></div>
    <div><label>Player 4</label><input id="p4" list="playersList" placeholder="Type a name (or NONE)"/></div>
  </div>

  <div style="margin-top:10px">
    <span class="pill">Team Rank: <b id="teamRank">–</b></span>
    <span class="pill">Real players: <b id="realPlayers">0</b></span>
    <span class="pill">Divisor (0.1×rank): <b id="divisor">–</b></span>
  </div>

  <div class="muted" style="margin-top:8px;">
    Tip: start typing to filter the name list. Leave a slot blank or type <b>NONE</b> to count rank as 0.
    If you have exactly <b>3 real players</b>, the app adds <b>+0.15</b> to every placement multiplier.
  </div>
</div>

<div class="card">
  <h3 style="margin-top:0;">Kills needed</h3>

  <div class="grid grid-2" style="margin-bottom:10px;">
    <div>
      <label>Assumed placement</label>
      <select id="assumedPlacement"></select>

      <div style="height:10px;"></div>
      <label>Milestones (+1 each)</label>
      <input id="milestonesLabel" disabled/>
    </div>

    <div>
      <label>Target total score (best 4 games)</label>
      <input id="targetTotal" type="number" min="0" step="0.01" value="180"/>
      <div class="muted" style="margin-top:6px;">
        Counted games: <b>best 4</b>. Max points/game = <b>45</b>.
      </div>
    </div>
  </div>

  <div id="killsNeeded45" style="margin-bottom:10px;">Select players to calculate</div>
  <div id="killsNeededTarget">—</div>
</div>

<div class="card">
  <h3 style="margin-top:0;">Games (unlimited entries, counts best 4)</h3>
  <button id="addGameBtn">Add Game</button>
  <div id="games" style="margin-top:10px;"></div>
  <div style="margin-top:10px">
    <span class="pill">Best 4 Total: <b id="best4Total">0.00</b></span>
    <span class="pill">Remaining Possible: <b id="remainingPossible">180.00</b></span>
    <span class="pill">Games Entered: <b id="gamesEntered">0</b></span>
  </div>
  <div class="muted" style="margin-top:8px;">
    Games are displayed sorted by points (highest first). While typing kills, sorting waits until you finish (blur/change) so it won’t kick you out.
  </div>
</div>

<script>
const COUNTED_GAMES = 4;
const MAX_POINTS = 45;

const PLACEMENTS = [
  { key: "1st",      label: "1st",      base: 2.25 },
  { key: "2nd-3rd",  label: "2nd–3rd",  base: 1.50 },
  { key: "4th-5th",  label: "4th–5th",  base: 1.25 },
  { key: "6th-10th", label: "6th–10th", base: 1.00 },
  { key: "11th+",    label: "11th+",    base: 0.75 },
];

const MILESTONES = [60,70,75,80,85,95,100];

let rankings = [];
let rankByNameLower = new Map(); // lower(name) -> rank

// Game objects: {id, killsStr, killsInt, placement, points}
// We keep DOM nodes stable to avoid focus loss while typing.
let games = [];
let gameNodes = new Map(); // id -> element
let nextGameId = 1;

function milestonePoints(kills){
  const k = (typeof kills === "number" && isFinite(kills)) ? kills : 0;
  return MILESTONES.filter(m=>k>=m).length;
}

function placementMulti(placementKey, realPlayers){
  const p = PLACEMENTS.find(x => x.key === placementKey) || PLACEMENTS[0];
  return p.base + ((realPlayers === 3) ? 0.15 : 0.0);
}

function parseCSVLine(line){
  const out = [];
  let cur = "";
  let inQ = false;
  for (let i=0;i<line.length;i++){
    const ch = line[i];
    if (ch === '"') {
      if (inQ && line[i+1] === '"') { cur += '"'; i++; }
      else inQ = !inQ;
    } else if (ch === ',' && !inQ) {
      out.push(cur);
      cur = "";
    } else {
      cur += ch;
    }
  }
  out.push(cur);
  return out.map(s => s.trim());
}

async function loadCSV() {
  const url = "rankings.csv?ts=" + Date.now();
  const text = await fetch(url, { cache: "no-store" }).then(r=>r.text());

  const lines = text.replace(/\r/g,"").split("\n").filter(l => l.trim().length);
  if (!lines.length) throw new Error("rankings.csv is empty");

  const headers = parseCSVLine(lines.shift()).map(h => h.toLowerCase());
  const nameIdx = headers.indexOf("name");
  const rankIdx = headers.indexOf("rank");
  if (nameIdx === -1 || rankIdx === -1) throw new Error("rankings.csv must have headers: name,rank");

  rankings = [];
  rankByNameLower = new Map();

  lines.forEach(l=>{
    const cols = parseCSVLine(l);
    const name = String(cols[nameIdx] ?? "").trim();
    const rank = parseFloat(String(cols[rankIdx] ?? "0").trim());
    if (!name) return;
    const r = isFinite(rank) ? rank : 0;
    rankings.push({ name, rank: r });
    rankByNameLower.set(name.toLowerCase(), r);
  });

  rankings.sort((a,b)=>a.name.localeCompare(b.name, undefined, {sensitivity:"base"}));
  buildDatalist();
  fillPlacements();
  hookInputs();
  document.getElementById("milestonesLabel").value = MILESTONES.join(", ");
  updateTeam(true);
}

function buildDatalist(){
  const dl = document.getElementById("playersList");
  dl.innerHTML = "";

  const none = document.createElement("option");
  none.value = "NONE";
  none.label = "NONE (0)";
  dl.appendChild(none);

  rankings.forEach(r=>{
    const opt = document.createElement("option");
    opt.value = r.name;
    opt.label = `${r.name} (${r.rank})`;
    dl.appendChild(opt);
  });
}

// ===== Autocomplete dropdown (works on mobile too) =====
function getAllPlayerNames(){
  // rankings are loaded from CSV; build list each time so it's always current
  const names = ["NONE", ...rankings.map(r => r.name)];
  return names;
}

function getRankForName(name){
  if(!name) return null;
  if(name.toLowerCase() === "none") return 0;
  const r = rankByNameLower.get(name.toLowerCase());
  return (typeof r === "number") ? r : null;
}

function showSuggestions(inputId){
  const input = document.getElementById(inputId);
  const box = document.getElementById("sug-" + inputId);
  if(!input || !box) return;

  const q = (input.value || "").trim().toLowerCase();
  const names = getAllPlayerNames();

  // Filter: contains match (better for typos); prefer startsWith
  let matches = names.filter(n => n.toLowerCase().includes(q));
  matches.sort((a,b)=>{
    const al = a.toLowerCase(), bl = b.toLowerCase();
    const as = q && al.startsWith(q), bs = q && bl.startsWith(q);
    if(as !== bs) return as ? -1 : 1;
    return a.localeCompare(b, undefined, {sensitivity:"base"});
  });

  // If empty query, show first N alphabetically (NONE first)
  if(!q){
    const rest = rankings.map(r=>r.name).slice().sort((a,b)=>a.localeCompare(b, undefined, {sensitivity:"base"}));
    matches = ["NONE", ...rest];
  }

  matches = matches.slice(0, 12);

  if(matches.length === 0){
    box.style.display = "none";
    box.innerHTML = "";
    return;
  }

  box.innerHTML = matches.map((name, idx)=>{
    const rank = getRankForName(name);
    const meta = (rank === null) ? "" : `<span class="suggestionMeta">(${rank})</span>`;
    return `<div class="suggestionItem" data-name="${escapeHtml(name)}" data-idx="${idx}">${escapeHtml(name)} ${meta}</div>`;
  }).join("");

  box.querySelectorAll(".suggestionItem").forEach(item=>{
    item.addEventListener("mousedown", (e) => { e.preventDefault(); }); // prevent blur before click
    item.addEventListener("click", () => {
      const name = item.getAttribute("data-name");
      input.value = unescapeHtml(name);
      hideSuggestions(inputId);
      updateTeam(true);
      saveState();
    });
  });

  // reset active index
  box.dataset.active = "-1";
  box.style.display = "block";
}

function hideSuggestions(inputId){
  const box = document.getElementById("sug-" + inputId);
  if(!box) return;
  box.style.display = "none";
  box.innerHTML = "";
  box.dataset.active = "-1";
}

function handleSuggestKeys(e, inputId){
  const box = document.getElementById("sug-" + inputId);
  const input = document.getElementById(inputId);
  if(!box || !input) return;

  const isOpen = box.style.display === "block";
  if(!isOpen && (e.key === "ArrowDown" || e.key === "ArrowUp")){
    showSuggestions(inputId);
    return;
  }
  if(!isOpen) return;

  const items = Array.from(box.querySelectorAll(".suggestionItem"));
  if(items.length === 0) return;

  let active = parseInt(box.dataset.active || "-1", 10);
  if(e.key === "ArrowDown"){
    e.preventDefault();
    active = Math.min(items.length - 1, active + 1);
  }else if(e.key === "ArrowUp"){
    e.preventDefault();
    active = Math.max(0, active - 1);
  }else if(e.key === "Enter"){
    if(active >= 0 && active < items.length){
      e.preventDefault();
      items[active].click();
    }
    return;
  }else if(e.key === "Escape"){
    hideSuggestions(inputId);
    return;
  }else{
    return;
  }

  items.forEach((it, i)=> it.classList.toggle("active", i === active));
  box.dataset.active = String(active);
  const it = items[active];
  if(it) it.scrollIntoView({block:"nearest"});
}

// tiny helpers so we can store names safely in data attributes
function escapeHtml(str){
  return String(str).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#039;");
}
function unescapeHtml(str){
  const t = document.createElement("textarea");
  t.innerHTML = str;
  return t.value;
}


function fillPlacements(){
  const s = document.getElementById("assumedPlacement");
  s.innerHTML = "";
  PLACEMENTS.forEach(p=>{
    const o = document.createElement("option");
    o.value = p.key;
    o.textContent = p.label;
    s.appendChild(o);
  });
  s.value = "1st";
  s.addEventListener("change", () => updateTeam(true));
}

function hookInputs(){
  // Player inputs
  ["p1","p2","p3","p4"].forEach(id=>{
    const el = document.getElementById(id);
    el.addEventListener("input", () => {
      showSuggestions(id);
      updateTeam(false);
    });
    el.addEventListener("focus", () => showSuggestions(id));
    el.addEventListener("keydown", (e) => handleSuggestKeys(e, id));
    el.addEventListener("change", () => updateTeam(true));
    el.addEventListener("blur", () => {
      // delay so click on suggestion works
      setTimeout(() => hideSuggestions(id), 120);
      updateTeam(true);
    });
  });

  // Target changes
  document.getElementById("targetTotal").addEventListener("input", () => {
    const rankTxt = document.getElementById("teamRank").textContent;
    if(rankTxt !== "–"){
      calcKillsNeededBlocks(parseFloat(rankTxt), parseInt(document.getElementById("realPlayers").textContent || "0", 10));
      updateReplacementHelper();
    }
    saveState();
  });

  // Buttons
  document.getElementById("addGameBtn").addEventListener("click", () => addGame());

  document.getElementById("resetBtn").addEventListener("click", () => {
    // Reset players, games, and target score; keep static data (placements, multipliers, CSV)
    ["p1","p2","p3","p4"].forEach(id => {
      const el = document.getElementById(id);
      if(el) el.value = "";
      hideSuggestions(id);
    });

    const target = document.getElementById("targetTotal");
    if(target) target.value = 180;

    games = [];
    gameNodes.forEach(n => n.remove());
    gameNodes.clear();
    nextGameId = 1;

    saveState();
    updateTeam(true);
  });
}

function normalizeName(raw){
  let v = String(raw ?? "").trim();
  if (!v) return "";
  const idx = v.lastIndexOf(" (");
  if (idx > 0 && v.endsWith(")")) v = v.slice(0, idx).trim();
  return v;
}

function computeTeam(){
  const ids = ["p1","p2","p3","p4"];
  let teamRank = 0;
  let realPlayers = 0;

  ids.forEach(id=>{
    const typed = normalizeName(document.getElementById(id).value);
    if (!typed) return;
    if (typed.toLowerCase() === "none") return;

    const r = rankByNameLower.get(typed.toLowerCase());
    if (typeof r === "number"){
      teamRank += r;
      realPlayers += 1;
    }
  });

  return { teamRank, realPlayers };
}

function gamePointsFromKills(kills, placementKey, teamRank, realPlayers){
  const k = (typeof kills === "number" && isFinite(kills)) ? kills : 0;
  const div = teamRank * 0.1;
  const multi = placementMulti(placementKey, realPlayers);
  const raw = (k * multi / div) + milestonePoints(k);
  return Math.min(MAX_POINTS, raw);
}

function minKillsForTarget(perGameTarget, placementKey, teamRank, realPlayers){
  if (perGameTarget <= 0) return 0;
  if (perGameTarget > MAX_POINTS) return null;
  let kills = 0;
  while (kills <= 5000){
    if (gamePointsFromKills(kills, placementKey, teamRank, realPlayers) >= perGameTarget) return kills;
    kills++;
  }
  return null;
}

function updateTeam(forceSort){
  const { teamRank, realPlayers } = computeTeam();
  document.getElementById("realPlayers").textContent = String(realPlayers);

  if (teamRank <= 0){
    document.getElementById("teamRank").textContent="–";
    document.getElementById("divisor").textContent="–";
    document.getElementById("killsNeeded45").textContent="Select players to calculate";
    document.getElementById("killsNeededTarget").textContent="—";
    recalc(forceSort);
    return;
  }

  document.getElementById("teamRank").textContent = teamRank.toFixed(2);
  document.getElementById("divisor").textContent = (teamRank*0.1).toFixed(2);

  calcKillsNeededBlocks(teamRank, realPlayers);
  recalc(forceSort);
}

function calcKillsNeededBlocks(teamRank, realPlayers){
  const placementKey = document.getElementById("assumedPlacement").value || "1st";
  const placementLabel = PLACEMENTS.find(p=>p.key===placementKey)?.label || placementKey;
  const multi = placementMulti(placementKey, realPlayers);
  const div = teamRank*0.1;

  const k45 = minKillsForTarget(45, placementKey, teamRank, realPlayers);
  document.getElementById("killsNeeded45").innerHTML =
    `<b>${k45 ?? "—"}</b> kills needed for a <b>45-point</b> game as <b>${placementLabel}</b>.
     <div class="muted" style="margin-top:6px;">
       (Multiplier <b>${multi.toFixed(2)}</b>, divisor <b>${div.toFixed(2)}</b>, milestones included, capped at 45)
     </div>`;

  const targetTotal = parseFloat(document.getElementById("targetTotal").value || "0");
  const perGameTarget = targetTotal / COUNTED_GAMES;

  if (!isFinite(targetTotal) || targetTotal < 0){
    document.getElementById("killsNeededTarget").innerHTML = `<span class="muted">Enter a valid target total.</span>`;
    return;
  }
  if (perGameTarget > MAX_POINTS){
    document.getElementById("killsNeededTarget").innerHTML =
      `<span class="muted">Target total <b>${targetTotal.toFixed(2)}</b> implies <b>${perGameTarget.toFixed(2)}</b> points/game, but max is <b>45</b>.</span>`;
    return;
  }

  const kTarget = minKillsForTarget(perGameTarget, placementKey, teamRank, realPlayers);
  document.getElementById("killsNeededTarget").innerHTML =
    `<b>${kTarget ?? "—"}</b> kills/game to average <b>${perGameTarget.toFixed(2)}</b> points/game (target total <b>${targetTotal.toFixed(2)}</b>), as <b>${placementLabel}</b>.`;
}

function addGame(){
  const id = nextGameId++;
  const g = { id, killsStr: "", killsInt: null, placement: "1st", points: 0 };
  games.push(g);

  const node = createGameNode(g);
  gameNodes.set(id, node);
  document.getElementById("games").appendChild(node);

  recalc(true);
}

function createGameNode(g){
  const wrapper = document.createElement("div");
  wrapper.className = "gameRow";
  wrapper.dataset.gameId = String(g.id);

  wrapper.innerHTML = `
    <div class="gameHead">
      <strong id="title-${g.id}">Game</strong>
      <button class="inlineBtn" id="remove-${g.id}">Remove</button>
    </div>

    <div class="row" style="margin-top:10px;">
      <div>
        <label>Total team kills (combined)</label>
        <input type="number" min="0" placeholder="Enter kills" id="kills-${g.id}" value="">
      </div>
      <div>
        <label>Placement</label>
        <select id="place-${g.id}"></select>
      </div>
    </div>

    <div class="muted" style="margin-top:8px;">
      Milestone points: <b id="mile-${g.id}">0</b>
      &nbsp;|&nbsp; Game points: <b id="pts-${g.id}">0.00</b> (capped at 45)
    </div>
  `;

  const placeSel = wrapper.querySelector(`#place-${g.id}`);
  PLACEMENTS.forEach(p=>{
    const opt = document.createElement("option");
    opt.value = p.key;
    opt.textContent = p.label;
    placeSel.appendChild(opt);
  });
  placeSel.value = g.placement;

  // Remove
  wrapper.querySelector(`#remove-${g.id}`).addEventListener("click", () => {
    games = games.filter(x => x.id !== g.id);
    const node = gameNodes.get(g.id);
    if (node) node.remove();
    gameNodes.delete(g.id);
    recalc(true);
  });

  const killsInput = wrapper.querySelector(`#kills-${g.id}`);

  // On input: update without sorting (prevents focus loss / "backs out")
  killsInput.addEventListener("input", (e) => {
    const val = String(e.target.value ?? "");
    g.killsStr = val;
    const t = val.trim();
    if (t === ""){
      g.killsInt = null;
    } else {
      const n = parseInt(t, 10);
      g.killsInt = (isFinite(n) ? Math.max(0, n) : null);
    }
    recalc(false);
  });

  // On blur/change: allow sorting
  killsInput.addEventListener("change", () => recalc(true));
  killsInput.addEventListener("blur", () => recalc(true));

  placeSel.addEventListener("change", (e) => {
    g.placement = e.target.value;
    recalc(true);
  });

  return wrapper;
}

function recalc(forceSort){
  const rankTxt = document.getElementById("teamRank").textContent;
  const realPlayers = parseInt(document.getElementById("realPlayers").textContent || "0", 10);

  let teamRank = null;
  if (rankTxt !== "–") teamRank = parseFloat(rankTxt);

  // compute points for each game, update UI for each game row (no re-render)
  games.forEach(g=>{
    const kills = (typeof g.killsInt === "number") ? g.killsInt : 0;
    if (teamRank && teamRank > 0){
      g.points = gamePointsFromKills(kills, g.placement, teamRank, realPlayers);
    } else {
      g.points = 0;
    }
    const node = gameNodes.get(g.id);
    if (node){
      node.querySelector(`#mile-${g.id}`).textContent = String(milestonePoints(kills));
      node.querySelector(`#pts-${g.id}`).textContent = g.points.toFixed(2);
    }
  });

  // best 4 total
  const sortedByPts = [...games].sort((a,b) => (b.points - a.points) || (a.id - b.id));
  const best4 = sortedByPts.slice(0, COUNTED_GAMES);
  const best4Total = best4.reduce((s,g)=>s+g.points,0);

  const maxTotal = COUNTED_GAMES * MAX_POINTS;
  const remaining = Math.max(0, maxTotal - best4Total);

  document.getElementById("best4Total").textContent = best4Total.toFixed(2);
  document.getElementById("remainingPossible").textContent = remaining.toFixed(2);
  document.getElementById("gamesEntered").textContent = String(games.length);

  // Sort display order by points (if requested)
  if (forceSort){
    const active = document.activeElement;
    const activeInfo = active ? {
      id: active.id,
      start: (active.selectionStart ?? null),
      end: (active.selectionEnd ?? null),
    } : null;

    const container = document.getElementById("games");
    // Re-order existing nodes (no recreation)
    sortedByPts.forEach((g, idx) => {
      const node = gameNodes.get(g.id);
      if (node) container.appendChild(node);
      // Title shows rank in list
      const title = node ? node.querySelector(`#title-${g.id}`) : null;
      if (title) title.textContent = `Game (Rank ${idx+1})`;
    });

    // Restore focus/caret if possible
    if (activeInfo && activeInfo.id){
      const el = document.getElementById(activeInfo.id);
      if (el){
        el.focus({ preventScroll: true });
        if (typeof activeInfo.start === "number" && typeof activeInfo.end === "number"){
          try { el.setSelectionRange(activeInfo.start, activeInfo.end); } catch {}
        }
      }
    }
  }
}

loadCSV().catch(e=>alert(e.message));
</script>
</body>
</html>
