<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>The Krew • TKR Arena Scoring</title>
<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Ctext y='50' font-size='50'%3E%F0%9F%92%A5%3C/text%3E%3C/svg%3E">
  <style>
    :root{
      --bg:#07020f;
      --text:#fff7fb;
      --muted: rgba(255,247,251,.72);

      --card: rgba(18,6,28,.88);
      --card2: rgba(12,4,20,.92);

      --accent:#ff3bd4;          /* neon magenta */
      --accent2:#ffb000;         /* ember gold */
      --border: rgba(255, 59, 212, .22);
      --border2: rgba(255, 59, 212, .55);
      --glow: rgba(255, 59, 212, .16);

      --btn: rgba(255, 59, 212, .14);
      --btnHover: rgba(255, 59, 212, .22);

      --pillBg: rgba(12,4,20,.96);
    }

    *{ box-sizing:border-box; }

    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:var(--bg);
      color:var(--text);
      margin:0;
      padding:20px;
    }

    h1{ margin:0 0 14px 0; letter-spacing:.3px; }
    h3{ margin:0 0 10px 0; }

    .card{
      overflow: visible;

      background:var(--card);
      border:1px solid var(--border);
      border-radius:12px;
      padding:12px;
      margin-bottom:14px;
      box-shadow: 0 0 0 1px var(--glow), 0 8px 30px rgba(0,0,0,.45);
      backdrop-filter: blur(6px);
    }

    label{
      font-size:12px;
      color:var(--muted);
      display:block;
      margin-bottom:4px;
    }

    input, select, button{
      width:100%;
      padding:7px;
      border-radius:10px;
      border:1px solid var(--border2);
      background:var(--card2);
      color:var(--text);
      box-shadow: 0 0 0 1px rgba(176, 80, 255, .10), 0 0 18px rgba(176, 80, 255, .10);
      outline:none;
      font-size:14px;
    }

    input:focus, select:focus{
      box-shadow: 0 0 0 2px rgba(176, 80, 255, .35), 0 0 26px rgba(176, 80, 255, .18);
    }

    button{
      cursor:pointer;
      background:var(--btn);
      border:1px solid rgba(176,80,255,.85);
      color:var(--text);
      box-shadow: 0 0 18px rgba(176,80,255,.16);
    }
    button:hover{
      background:var(--btnHover);
      box-shadow: 0 0 26px rgba(176,80,255,.22);
    }

    .grid{ display:grid; gap:16px; }
    .grid-4{ grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); }
    .grid-2{ grid-template-columns: 1fr 1fr; }
    @media (max-width:900px){
      .grid-2{ grid-template-columns: 1fr; }
    }

    .pill{
      display:inline-block;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid var(--border2);
      background:var(--pillBg);
      font-size:12px;
      margin-right:5px;
      margin-top:5px;
    }

    .muted{ color:var(--muted); font-size:12px; }

    .row{
      display:flex;
      gap:16px;
      align-items:end;
      flex-wrap:wrap;
    }
    .row > *{
      flex: 1;
      min-width: 240px;
    }

    .gameRow{
      border:1px solid var(--border);
      border-radius:14px;
      padding:10px;
      margin-bottom:10px;
      background:var(--card2);
      box-shadow: 0 0 0 1px rgba(176,80,255,.18), 0 0 22px rgba(176,80,255,.10);
    }

    .gameHead{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .gameHead strong{ font-size:14px; }
    .inlineBtn{ width:auto; padding:7px 10px; min-width: 110px; }

    /* Smaller player search boxes */
    .playerInput{
      padding:5px 8px;
      font-size:13px;
      border-radius:10px;
    }

    /* Autocomplete dropdown */
    .playerWrap{ position:relative; }
    .suggestions{
      position:absolute;
      top:calc(100% + 6px);
      left:0; right:0;
      max-height:220px;
      overflow:auto;
      background:var(--card2);
      border:1px solid var(--border2);
      border-radius:12px;
      z-index: 10000;
      display:none;
      box-shadow: 0 0 0 1px rgba(176,80,255,.14), 0 16px 40px rgba(0,0,0,.55);
    }
    .suggestionItem{
      padding:8px 10px;
      cursor:pointer;
      border-bottom:1px solid rgba(176,80,255,.18);
      font-size:13px;
      line-height:1.2;
    }
    .suggestionItem:last-child{ border-bottom:none; }
    .suggestionItem:hover, .suggestionItem.active{
      background: rgba(176, 80, 255, .14);
    }
    .suggestionMeta{ color: var(--muted); font-size:12px; margin-left:6px; }


    /* Mobile: suggestions render as fixed overlay above everything */
    .suggestions.fixed{
      position: fixed !important;
      left: 12px !important;
      right: auto !important;
      top: 0;
      width: calc(100vw - 24px) !important;
      max-height: 45vh !important;
      overflow:auto;
      z-index: 99999 !important;
      pointer-events: auto;
    }

    .spacer8{ height:8px; }
    .spacer10{ height:10px; }
  
/* === Arena Energy Theme === */

/* Animated arena glow */
body::before{
  content:"";
  position:fixed;
  inset:-30%;
  background:
    radial-gradient(circle at 20% 15%, rgba(255,59,212,.12), transparent 40%),
    radial-gradient(circle at 80% 85%, rgba(255,176,0,.10), transparent 45%),
    radial-gradient(circle at 60% 30%, rgba(255,59,212,.06), transparent 50%);
  filter: blur(2px);
  pointer-events:none;
  z-index:-2;
  animation: arenaDrift 18s ease-in-out infinite;
}
@keyframes arenaDrift{
  0%,100%{ transform: translate3d(0,0,0) scale(1); }
  50%{ transform: translate3d(-2%,1%,0) scale(1.02); }
}

/* Subtle scanlines */
body::after{
  content:"";
  position:fixed;
  inset:0;
  background: repeating-linear-gradient(
    to bottom,
    rgba(255,255,255,.03) 0px,
    rgba(255,255,255,.03) 1px,
    transparent 3px,
    transparent 6px
  );
  opacity:.07;
  mix-blend-mode: overlay;
  pointer-events:none;
  z-index:-1;
}

/* Cards feel like panels */
.card{
  background: linear-gradient(180deg, rgba(10,12,22,.92), rgba(7,9,18,.86));
  border: 1px solid rgba(255,59,212,.18);
  box-shadow:
    0 0 0 1px rgba(255,59,212,.10),
    0 18px 50px rgba(0,0,0,.62);
  position:relative;
  overflow:visible;
}
.card::before{
  content:"";
  position:absolute;
  inset:-2px;
  background: linear-gradient(90deg, rgba(255,59,212,.0), rgba(255,59,212,.10), rgba(255,176,0,.08), rgba(255,59,212,.0));
  opacity:.55;
  transform: translateX(-60%);
  animation: sheen 10s linear infinite;
  pointer-events:none;
}
@keyframes sheen{
  0%{ transform: translateX(-60%); }
  100%{ transform: translateX(60%); }
}

/* Headings */
h1{
  text-transform: uppercase;
  letter-spacing: .6px;
  text-shadow: 0 0 22px rgba(255,59,212,.18);
}
h3{
  text-transform: uppercase;
  letter-spacing:.4px;
}

/* Inputs: less border, more focus energy */
input, select{
  border: 1px solid rgba(255,59,212,.26);
  box-shadow: 0 0 10px rgba(255,59,212,.06);
}
input:focus, select:focus{
  border-color: rgba(255,59,212,.65);
  box-shadow: 0 0 0 2px rgba(255,59,212,.22), 0 0 16px rgba(255,59,212,.14);
}

/* Buttons */
button{
  border:1px solid rgba(255,59,212,.60);
  box-shadow: 0 0 18px rgba(255,59,212,.10);
}
button:hover{
  box-shadow: 0 0 26px rgba(255,59,212,.18);
}

/* Pills */
.pill{
  border-color: rgba(255,59,212,.50);
  box-shadow: 0 0 14px rgba(255,59,212,.08);
}

/* Progress meter */
.meterWrap{
  margin-top:10px;
  padding:10px;
  border-radius:14px;
  border:1px solid rgba(255,59,212,.22);
  background: linear-gradient(180deg, rgba(7,9,18,.92), rgba(6,7,14,.92));
  box-shadow: 0 0 18px rgba(255,59,212,.08);
}
.meterTop{
  display:flex;
  gap:10px;
  align-items:center;
  justify-content:space-between;
  flex-wrap:wrap;
}
.meterBar{
  height:12px;
  border-radius:999px;
  background: rgba(255,255,255,.06);
  border:1px solid rgba(255,59,212,.18);
  overflow:hidden;
}
.meterFill{
  height:100%;
  width:0%;
  border-radius:999px;
  background: linear-gradient(90deg, rgba(255,59,212,.95), rgba(255,176,0,.75));
  box-shadow: 0 0 22px rgba(255,59,212,.18);
  transition: width .35s ease;
}
.meterMeta{
  font-size:12px;
  color: var(--muted);
}

/* Game heat + counted */
.gameRow{
  border-color: rgba(255,255,255,.10);
}
.gameRow.counted{
  border-color: rgba(255,59,212,.55);
  box-shadow: 0 0 0 1px rgba(255,59,212,.14), 0 0 22px rgba(255,59,212,.10);
}
.gameRow.game-hot{
  border-color: rgba(255,59,212,.75) !important;
  box-shadow: 0 0 0 1px rgba(255,59,212,.18), 0 0 28px rgba(255,59,212,.14);
}
.gameRow.game-mid{
  border-color: rgba(255,59,212,.40) !important;
}
.gameRow.game-low{
  border-color: rgba(255,255,255,.12) !important;
}
.badge{
  display:inline-block;
  margin-left:8px;
  padding:3px 8px;
  border-radius:999px;
  font-size:12px;
  border:1px solid rgba(255,59,212,.45);
  background: rgba(7,9,18,.92);
  color: var(--text);
}
.badge.top{
  border-color: rgba(255,59,212,.70);
  box-shadow: 0 0 18px rgba(255,59,212,.12);
}


/* Header accent bar */
h3{
  position:relative;
  padding-bottom:8px;
}
h3::after{
  content:"";
  position:absolute;
  left:0;
  bottom:0;
  width:160px;
  height:3px;
  border-radius:999px;
  background: linear-gradient(90deg, rgba(255,59,212,.9), rgba(255,176,0,.85));
  box-shadow: 0 0 18px rgba(255,59,212,.14);
}
h1{
  background: linear-gradient(90deg, rgba(255,59,212,1), rgba(255,176,0,1));
  -webkit-background-clip: text;
  background-clip:text;
  color: transparent;
  text-shadow:none;
}


    /* (datalist doesn't render, but kept for JS compatibility) */
.gamesList{ display:flex; flex-direction:column; gap:10px; margin-top:6px; }
    .gameRow{ display:grid; grid-template-columns: 110px 1fr 1fr 110px; gap:10px; align-items:end; }
    @media (max-width: 520px){
      .gameRow{ grid-template-columns: 1fr 1fr; }
      .gameRow .colLabel{ grid-column: 1 / -1; }
      .gameRow .colScore{ grid-column: 1 / -1; }
    }
    .colScore{ padding:10px 12px; border:1px solid rgba(255,255,255,.10); border-radius:12px; background: rgba(0,0,0,.15); }
    .scoreBig{ font-weight:900; font-size:18px; letter-spacing:.3px; }
    .scoreSub{ font-size:12px; opacity:.8; margin-top:2px; }
</style>
</head>
<body>
<form autocomplete="off">

<h1>THE KREW • TKR SCORING</h1>
<div class="muted" style="margin:-6px 0 14px 0;"></div>

<div class="card">
  <h3>SQUAD BUILDER</h3>

  <datalist id="playersList"></datalist>

  

  <div class="grid grid-4">
    <div class="playerWrap">
      <label>Player 1</label>
      <input class="playerInput" id="p1" placeholder="Type a name (or NONE)" autocomplete="off" autocapitalize="off" spellcheck="false"/ list="playersList">
      <div class="suggestions" id="sug-p1"></div>
    </div>
    <div class="playerWrap">
      <label>Player 2</label>
      <input class="playerInput" id="p2" placeholder="Type a name (or NONE)" autocomplete="off" autocapitalize="off" spellcheck="false"/ list="playersList">
      <div class="suggestions" id="sug-p2"></div>
    </div>
    <div class="playerWrap">
      <label>Player 3</label>
      <input class="playerInput" id="p3" placeholder="Type a name (or NONE)" autocomplete="off" autocapitalize="off" spellcheck="false"/ list="playersList">
      <div class="suggestions" id="sug-p3"></div>
    </div>
    <div class="playerWrap">
      <label>Player 4</label>
      <input class="playerInput" id="p4" placeholder="Type a name (or NONE)" autocomplete="off" autocapitalize="off" spellcheck="false"/ list="playersList">
      <div class="suggestions" id="sug-p4"></div>
    </div>
  </div>

  <div style="margin-top:10px">
    <span class="pill">Squad Rank: <b id="teamRank">–</b></span>
    <span class="pill muted" id="csvStatus" style="display:none"></span>
    <span id="realPlayers" style="display:none">0</span>
    <span id="divisor" style="display:none">–</span>
  </div>

  </div>
<div class="card">
  <h3>KILL TARGETS</h3>

  <div class="grid grid-2" style="margin-bottom:10px;">
    <div>
      <label>Assumed placement</label>
      <!-- Static fallback options (JS also fills these) -->
      <select id="assumedPlacement">
        <option value="1st">1st</option>
        <option value="2nd">2nd</option>
        <option value="3rd">3rd</option>
        <option value="4th">4th</option>
        <option value="5th">5th</option>
        <option value="6th+">6th+</option>
      </select>

      
    </div>

    <div>
      <label>Target total score</label>
      <input id="targetTotal" type="number" min="0" step="0.01" value="200"/>
      <div class="muted" style="margin-top:6px;">
        Played maps: <b>7</b>; counted: <b>best 6</b>.
      </div>
    </div>
  </div>

  <div id="killsNeeded45" style="margin-top:6px;" class="muted">Select your squad to see kill targets.</div>
</div>

<div class="card">
  <h3>MATCH LOG</h3>

  <div id="games" style="margin-top:10px;"></div>

  <div style="margin-top:10px">
    <span class="pill">Total (best 6 of 7): <b id="best4Total">0</b></span>
    <span class="pill">Maps logged: <b id="gamesEntered">0</b></span>
    <span id="remainingPossible" style="display:none">0</span>
  </div>

  <div class="meterMeta">Total: <b id="meterBest4">0.00</b> / Target: <b id="meterTarget">180.00</b></div>
    </div>
    <div class="spacer8"></div>
    <div class="meterBar"><div class="meterFill" id="meterFill"></div></div>
  </div>

  <div class="spacer8"></div>

  <div class="spacer10"></div>
  <!-- Buttons moved to bottom -->
  <div class="row">
    <button id="resetBtn" type="button" title="Resets players, games, and target score">Reset</button>
  </div>
</div>
</div>


<script>
const TOTAL_MAPS = 7;
const BEST_COUNTED = 6;
const MAX_POINTS = null; // no per-game cap in new rules

// Local save (per device)
const STORAGE_KEY = "tkr_calc_state_all_v1";
const TTL_MS = 24 * 60 * 60 * 1000; // 24 hours

// Device detection for dropdown behavior (Samsung Internet friendly)
const IS_MOBILE = (
  (window.matchMedia && window.matchMedia("(pointer: coarse)").matches) ||
  ("ontouchstart" in window) ||
  (navigator.maxTouchPoints > 0)
);
let selectingSuggestion = false;

// Placement multipliers (4-player baseline). Trio-quad (3 real players) adds +0.15
const PLACEMENTS = [
  { key: "1st",  label: "1st",  points: 25 },
  { key: "2nd",  label: "2nd",  points: 15 },
  { key: "3rd",  label: "3rd",  points: 9  },
  { key: "4th",  label: "4th",  points: 6  },
  { key: "5th",  label: "5th",  points: 3  },
  { key: "6th+", label: "6th+", points: 0  },
];

// Milestones (+1 each)
const MILESTONES = [50,60,70,80,90,100];

let rankings = [];
let rankByNameLower = new Map(); // lower(name) -> rank

// Games: {id, killsStr, killsInt, placement, points}
let games = [];

function initGamesFixed(){
  // 6 main maps + 1 reset map
  games = [];
  for(let i=1;i<=6;i++){
    games.push({ id: i, label: `Map ${i}`, killsStr: "", killsInt: 0, placement: "", points: 0, isReset: false });
  }
  games.push({ id: 7, label: "Reset (Map 7)", killsStr: "", killsInt: 0, placement: "", points: 0, isReset: true });
}

// DOM cache for the fixed 7-map editor
let gameNodes = window.__tkr_gameNodes || (window.__tkr_gameNodes = new Map());

function renderGames(){
  const host = document.getElementById("games");
  if(!host) return;
  host.innerHTML = "";
  gameNodes.clear();

  games.forEach(g => {
    const node = createGameNode(g);
    gameNodes.set(g.id, node);
    host.appendChild(node);
  });
}

let gameNodes = new Map(); // id -> element
let nextGameId = 1;

// ===== small helpers =====
function nowMs(){ return Date.now(); }
function escapeHtml(str){
  return String(str).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#039;");
}
function unescapeHtml(str){
  const t = document.createElement("textarea");
  t.innerHTML = str;
  return t.value;
}
function parseCSVLine(line){
  const out = [];
  let cur = "";
  let inQ = false;
  for(let i=0;i<line.length;i++){
    const ch = line[i];
    if(ch === '"'){
      if(inQ && line[i+1] === '"'){ cur += '"'; i++; }
      else inQ = !inQ;
    }else if(ch === ',' && !inQ){
      out.push(cur); cur = "";
    }else cur += ch;
  }
  out.push(cur);
  return out.map(s => s.trim());
}

// ===== persistence =====
function saveState(){
  try{
    const state = {
      savedAt: nowMs(),
      team: {
        p1: document.getElementById("p1").value || "",
        p2: document.getElementById("p2").value || "",
        p3: document.getElementById("p3").value || "",
        p4: document.getElementById("p4").value || ""
      },
      settings: {
        assumedPlacement: document.getElementById("assumedPlacement").value || "1st",
        targetTotal: document.getElementById("targetTotal").value || ""
      },
      games: games.map(g => ({
        id: g.id,
        killsStr: g.killsStr ?? "",
        killsInt: (typeof g.killsInt === "number" ? g.killsInt : null),
        placement: g.placement || "1st"
      })),
      nextGameId
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  }catch(e){}
}

function loadState(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return false;
    const state = JSON.parse(raw);
    const age = nowMs() - (state.savedAt || 0);
    if(!isFinite(age) || age > TTL_MS){
      localStorage.removeItem(STORAGE_KEY);
      return false;
    }

    if(state.settings){
      if(state.settings.assumedPlacement) document.getElementById("assumedPlacement").value = state.settings.assumedPlacement;
      if(state.settings.targetTotal !== undefined) document.getElementById("targetTotal").value = state.settings.targetTotal;
    }

    if(state.team){
      ["p1","p2","p3","p4"].forEach(k=>{
        if(state.team[k] !== undefined) document.getElementById(k).value = state.team[k];
      });
    }

    // games
    games = [];
    gameNodes.forEach(n => n.remove());
    gameNodes.clear();

    nextGameId = (typeof state.nextGameId === "number" && state.nextGameId > 0) ? state.nextGameId : 1;

    if(Array.isArray(state.games)){
      state.games.forEach(sg=>{
        const id = (typeof sg.id === "number" && sg.id > 0) ? sg.id : nextGameId++;
        const g = {
          id,
          killsStr: (sg.killsStr ?? ""),
          killsInt: (typeof sg.killsInt === "number" ? sg.killsInt : null),
          placement: sg.placement || "1st",
          points: 0
        };
        games.push(g);
        const node = createGameNode(g);
        gameNodes.set(id, node);
        document.getElementById("games").appendChild(node);

        const killsEl = node.querySelector(`#kills-${id}`);
        if(killsEl) killsEl.value = g.killsStr || "";
        const placeEl = node.querySelector(`#place-${id}`);
        if(placeEl) placeEl.value = g.placement;
      });

      const maxId = games.reduce((m,g)=>Math.max(m,g.id), 0);
      if(nextGameId <= maxId) nextGameId = maxId + 1;
    }

    return true;
  }catch(e){
    return false;
  }
}

// ===== scoring =====
function milestonePoints(kills){
  const k = (typeof kills === "number" && isFinite(kills)) ? kills : 0;
  // Each milestone grants +5 points BEFORE dividing by (teamRank/10)
  return 5 * MILESTONES.filter(m => k >= m).length;
}

function placementPoints(placementKey){
  const p = PLACEMENTS.find(x => x.key === placementKey) || PLACEMENTS[0];
  return p.points || 0;
}

function gamePointsFromKills(kills, placementKey, teamRank){
  const k = (typeof kills === "number" && isFinite(kills)) ? kills : 0;
  const div = teamRank * 0.1;
  if(!(div > 0)) return 0;
  const placePts = placementPoints(placementKey);
  const ms = milestonePoints(k);
  const raw = (k + placePts + ms) / div;
  return raw;
}

function minKillsForTarget(targetPoints, placementKey, teamRank){
  if(!(targetPoints > 0)) return 0;
  const limit = 2500;
  for(let k=0; k<=limit; k++){
    const pts = gamePointsFromKills(k, placementKey, teamRank);
    if(pts + 1e-9 >= targetPoints) return k;
  }
  return null;
}

// ===== CSV loading =====
async function loadCSV(){
  const url = "rankings.csv?ts=" + Date.now();
  const r = await fetch(url, { cache: "no-store" });
  if(!r.ok) throw new Error("Failed to load rankings.csv (" + r.status + ")");
  const text = await r.text();

  const lines = text.replace(/
/g,"").split("
").filter(l => l.trim().length);
  if(!lines.length) throw new Error("rankings.csv is empty");

  const headers = parseCSVLine(lines.shift()).map(h => h.toLowerCase());
  const nameIdx = headers.indexOf("name");
  const rankIdx = headers.indexOf("rank");
  if(nameIdx === -1 || rankIdx === -1) throw new Error("rankings.csv must have headers: name,rank");

  rankings = [];
  rankByNameLower = new Map();

  lines.forEach(l=>{
    const cols = parseCSVLine(l);
    const name = String(cols[nameIdx] ?? "").trim();
    const rank = parseFloat(String(cols[rankIdx] ?? "0").trim());
    if(!name) return;
    const rnk = isFinite(rank) ? rank : 0;
    rankings.push({ name, rank: rnk });
    rankByNameLower.set(name.toLowerCase(), rnk);
  });

  rankings.sort((a,b)=>a.name.localeCompare(b.name, undefined, { sensitivity:"base" }));
  buildDatalist();
  const st = document.getElementById("csvStatus");
  if(st){ st.style.display='none'; st.textContent=''; }
}

function buildDatalist(){
  const dl = document.getElementById("playersList");
  if(!dl) return;
  dl.innerHTML = "";
const none = document.createElement("option");
  none.value = "NONE";
  none.label = "NONE (0)";
  dl.appendChild(none);

  rankings.forEach(r=>{
    const opt = document.createElement("option");
    opt.value = r.name;
    opt.label = `${r.name} (${r.rank})`;
    dl.appendChild(opt);
  });
}

function fillPlacements(){
  const s = document.getElementById("assumedPlacement");
  const current = s.value || "1st";
  // If the select is empty (or user has static fallback), ensure options exist and set value
  if(!s.options || s.options.length === 0){
    PLACEMENTS.forEach(p=>{
      const o = document.createElement("option");
      o.value = p.key;
      o.textContent = p.label;
      s.appendChild(o);
    });
  }
  s.value = current;
  s.addEventListener("change", () => {
    updateTeam(true);
    saveState();
  });
}

// ===== Autocomplete dropdown =====
function getAllPlayerNames(){
  return ["NONE", ...rankings.map(r => r.name)];
}
function getRankForName(name){
  if(!name) return null;
  if(name.toLowerCase() === "none") return 0;
  const r = rankByNameLower.get(name.toLowerCase());
  return (typeof r === "number") ? r : null;
}
function showSuggestions(inputId){
  const input = document.getElementById(inputId);
  const box = document.getElementById("sug-" + inputId);
  if(!input || !box) return;

  const q = (input.value || "").trim().toLowerCase();
  const names = getAllPlayerNames();

  let matches = names.filter(n => n.toLowerCase().includes(q));
  matches.sort((a,b)=>{
    const al = a.toLowerCase(), bl = b.toLowerCase();
    const as = q && al.startsWith(q), bs = q && bl.startsWith(q);
    if(as !== bs) return as ? -1 : 1;
    return a.localeCompare(b, undefined, {sensitivity:"base"});
  });

  if(!q){
    const rest = rankings.map(r=>r.name).slice().sort((a,b)=>a.localeCompare(b, undefined, {sensitivity:"base"}));
    matches = ["NONE", ...rest];
  }

  matches = matches.slice(0, 12);

  if(matches.length === 0){
    box.style.display = "none";
    box.innerHTML = "";
    return;
  }

  box.innerHTML = matches.map((name, idx)=>{
    const rank = getRankForName(name);
    const meta = (rank === null) ? "" : `<span class="suggestionMeta">(${rank})</span>`;
    return `<div class="suggestionItem" data-name="${escapeHtml(name)}" data-idx="${idx}">${escapeHtml(name)} ${meta}</div>`;
  }).join("");

  // Mobile: lift dropdown above all cards and align near the input
  box.dataset.active = "-1";
  box.style.display = "block";
  if(IS_MOBILE){
    box.classList.add("fixed");
    const r = input.getBoundingClientRect();
    const pad = 12;
    const top = Math.min(window.innerHeight - 12, r.bottom + 8);
    box.style.top = top + "px";
    box.style.left = pad + "px";
    box.style.width = `calc(100vw - ${pad*2}px)`;
  }else{
    box.classList.remove("fixed");
    box.style.top = "";
    box.style.left = "";
    box.style.width = "";
  }

  // Event delegation: reliable on Samsung Internet (fires before blur)
  const pick = (target) => {
    const item = target && target.closest ? target.closest(".suggestionItem") : null;
    if(!item) return;
    selectingSuggestion = true;
    const name = item.getAttribute("data-name");
    input.value = unescapeHtml(name);
    hideSuggestions(inputId);
    updateTeam(true);
    saveState();
    setTimeout(()=> selectingSuggestion = false, 0);
  };
  box.onpointerdown = (e) => { e.preventDefault(); e.stopPropagation(); pick(e.target); };
  box.ontouchstart = (e) => { e.preventDefault(); e.stopPropagation(); pick(e.target); };

}
function hideSuggestions(inputId){
  const box = document.getElementById("sug-" + inputId);
  if(!box) return;
  box.style.display = "none";
  box.innerHTML = "";
  box.dataset.active = "-1";
  box.classList.remove("fixed");
  box.style.top = "";
  box.style.left = "";
  box.style.width = "";
}
function handleSuggestKeys(e, inputId){
  const box = document.getElementById("sug-" + inputId);
  const input = document.getElementById(inputId);
  if(!box || !input) return;

  const isOpen = box.style.display === "block";
  if(!isOpen && (e.key === "ArrowDown" || e.key === "ArrowUp")){
    showSuggestions(inputId);
    return;
  }
  if(!isOpen) return;

  const items = Array.from(box.querySelectorAll(".suggestionItem"));
  if(items.length === 0) return;

  let active = parseInt(box.dataset.active || "-1", 10);
  if(e.key === "ArrowDown"){
    e.preventDefault();
    active = Math.min(items.length - 1, active + 1);
  }else if(e.key === "ArrowUp"){
    e.preventDefault();
    active = Math.max(0, active - 1);
  }else if(e.key === "Enter"){
    if(active >= 0 && active < items.length){
      e.preventDefault();
      items[active].click();
    }
    return;
  }else if(e.key === "Escape"){
    hideSuggestions(inputId);
    return;
  }else{
    return;
  }

  items.forEach((it, i)=> it.classList.toggle("active", i === active));
  box.dataset.active = String(active);
  const it = items[active];
  if(it) it.scrollIntoView({block:"nearest"});
}

// ===== UI & interactions =====
function hookInputs(){
  window.addEventListener('scroll', () => { if(IS_MOBILE){ ['p1','p2','p3','p4'].forEach(hideSuggestions); } }, {passive:true});
  window.addEventListener('resize', () => { if(IS_MOBILE){ ['p1','p2','p3','p4'].forEach(hideSuggestions); } });

  // Player inputs
  ["p1","p2","p3","p4"].forEach(id=>{
    const el = document.getElementById(id);
    el.addEventListener("input", () => {
      showSuggestions(id);
      updateTeam(false);
    });
    el.addEventListener("focus", () => showSuggestions(id));
    el.addEventListener("keydown", (e) => handleSuggestKeys(e, id));
    el.addEventListener("change", () => updateTeam(true));
    el.addEventListener("blur", () => {
      // On mobile, tapping a suggestion blurs first — don’t hide immediately.
      setTimeout(() => { if(!selectingSuggestion) hideSuggestions(id); }, 350);
      updateTeam(true);
    });
  });

  document.getElementById("targetTotal").addEventListener("input", () => {
    const rankTxt = document.getElementById("teamRank").textContent;
    if(rankTxt !== "–"){
      calcKillsNeededBlocks(parseFloat(rankTxt));
    }
    saveState();
  });

  
    document.getElementById("resetBtn").addEventListener("click", () => {
    // Reset players + games + target score.
    ["p1","p2","p3","p4"].forEach(id => {
      const el = document.getElementById(id);
      if(el) el.value = "";
      hideSuggestions(id);
    });
    const tgt = document.getElementById("targetTotal");
    if(tgt) tgt.value = "200";
    clearState();
    initGamesFixed();
    saveState();
    updateTeam(true);
    renderGames();
    recalc(true);
    try{ window.scrollTo({top:0, behavior:"smooth"}); }catch(e){}
  });
}

function normalizeName(raw){
  let v = String(raw ?? "").trim();
  if(!v) return "";
  const idx = v.lastIndexOf(" (");
  if(idx > 0 && v.endsWith(")")) v = v.slice(0, idx).trim();
  return v;
}

function computeTeam(){
  const ids = ["p1","p2","p3","p4"];
  let teamRank = 0;
  let realPlayers = 0;

  ids.forEach(id=>{
    const typed = normalizeName(document.getElementById(id).value);
    if(!typed) return;
    if(typed.toLowerCase() === "none") return;

    const r = rankByNameLower.get(typed.toLowerCase());
    if(typeof r === "number"){
      teamRank += r;
      realPlayers += 1;
    }
  });

  return { teamRank };
}

function calcKillsNeededBlocks(teamRank){
  const out = document.getElementById("killsNeeded45");
  if(!out) return;

  const placementKey = document.getElementById("assumedPlacement").value || "1st";
  const placementLabel = PLACEMENTS.find(p=>p.key===placementKey)?.label || placementKey;

  const main = games.filter(g => !g.isReset);
  const reset = games.find(g => g.isReset);

  // compute effective 6-game total (reset replaces lowest if better)
  let effective = [...main];

  if(reset && reset.placement && reset.killsStr !== ""){
    let li=-1, lv=Infinity;
    effective.forEach((g,i)=>{ if(g.points < lv){ lv=g.points; li=i; } });
    if(li>=0 && reset.points > lv){
      effective[li] = reset;
    }
  }

  const currentTotal = effective.reduce((s,g)=>s+(g.points||0),0);

  const targetTotal = parseFloat(document.getElementById("targetTotal").value || "0");
  if(!isFinite(targetTotal) || targetTotal < 0){
    out.textContent = "Enter a valid target.";
    return;
  }

  const loggedMain = main.filter(g => g.placement && g.killsStr !== "").length;
  const remaining = Math.max(0, 6 - loggedMain);
  const needed = Math.max(0, targetTotal - currentTotal);

  if(needed <= 0){
    out.innerHTML = `✅ On target. Total: <b>${currentTotal.toFixed(2)}</b> / <b>${targetTotal.toFixed(0)}</b>`;
    return;
  }

  if(remaining === 0){
    out.innerHTML = `All 6 main maps logged. Short by <b>${needed.toFixed(2)}</b> pts — improve with the reset map.`;
    return;
  }

  const perMapNeed = needed / remaining;
  const killsNeed = minKillsForTarget(perMapNeed, placementKey, teamRank);

  out.innerHTML =
    `Remaining: <b>${needed.toFixed(2)}</b> pts over <b>${remaining}</b> map(s). ` +
    `Need ~<b>${perMapNeed.toFixed(2)}</b> pts/map ⇒ <b>${killsNeed ?? "—"}</b> kills if you place <b>${placementLabel}</b>.`;
}

function updateReplacementHelper(){
  const card = document.getElementById("replacementCard");
  const summaryEl = document.getElementById("replaceSummary");
  const planEl = document.getElementById("replacePlan");
  if(!card || !summaryEl || !planEl) return;

  const rankTxt = document.getElementById("teamRank").textContent;
  if(rankTxt === "–"){
    card.style.display = "none";
    return;
  }
  const teamRank = parseFloat(rankTxt);
  if(!(teamRank > 0)){
    card.style.display = "none";
    return;
  }

  const normal = games.filter(g => !g.isReset).slice(0, TOTAL_MAPS);
  const reset = games.find(g => g.isReset) || null;

  if(normal.length < BEST_COUNTED){
    card.style.display = "none";
    return;
  }
  card.style.display = "block";

  const baseTotal = normal.reduce((s,g)=>s+g.points, 0);
  const lowest = normal.length ? normal.reduce((m,g)=>Math.min(m,g.points), Infinity) : 0;

  const targetTotal = parseFloat(document.getElementById("targetTotal").value || String(TOTAL_MAPS*0));
  const placementKey = document.getElementById("assumedPlacement").value || "1st";
  const placementLabel = PLACEMENTS.find(p=>p.key===placementKey)?.label || placementKey;

  // If reset exists and improves lowest (only meaningful once 7 maps are in)
  let effectiveTotal = baseTotal;
  let isReplacing = false;
  if(normal.length === TOTAL_MAPS && reset && reset.points > lowest){
    effectiveTotal = baseTotal - lowest + reset.points;
    isReplacing = true;
  }

  summaryEl.innerHTML =
    `<b>RESET GAME</b><div class="muted" style="margin-top:4px;">(shows after 6 maps logged)</div><br>` +
    `Logged maps: <b>${normal.length}</b>/7` +
    (reset ? ` • Reset logged: <b>Yes</b>` : ` • Reset logged: <b>No</b>`) +
    `<br>Lowest map (so far): <b>${(lowest===Infinity?0:lowest).toFixed(0)}</b> pts`;

  // If reset already logged, explain effect
  if(reset){
    planEl.innerHTML =
      `Reset score: <b>${reset.points.toFixed(0)}</b> pts.<br>` +
      (normal.length === TOTAL_MAPS
        ? (isReplacing
            ? `✅ Reset is replacing your lowest map. New total: <b>${effectiveTotal.toFixed(0)}</b>.`
            : `Reset does not beat your lowest map, so it won’t replace anything.`)
        : `Reset will only replace a map once all 7 maps are logged.`);
    return;
  }

  // If no reset yet, tell what reset would need to reach target (or just to improve)
  if(!isFinite(targetTotal) || targetTotal <= 0){
    planEl.innerHTML = `Set a <b>target total</b> to see what a reset game would need.`;
    return;
  }

  // Best-case with reset is: baseTotal - lowest + resetPts  (once 7 maps are logged)
  if(normal.length < TOTAL_MAPS){
    planEl.innerHTML =
      `You haven’t logged all 7 maps yet. A reset game will replace your lowest map once you’ve logged 8.`;
    return;
  }

  const neededResetScore = Math.max(0, Math.ceil(targetTotal - (baseTotal - lowest)));
  if(neededResetScore <= 0){
    planEl.innerHTML = `✅ You can already hit the target without needing a reset.`;
    return;
  }
  const kNeed = minKillsForTarget(neededResetScore, placementKey, teamRank);
  planEl.innerHTML =
    `To hit target <b>${targetTotal.toFixed(0)}</b>, your reset game needs about <b>${neededResetScore.toFixed(0)}</b> pts (replacing your lowest <b>${lowest.toFixed(0)}</b>).<br>` +
    `That’s roughly <b>${kNeed ?? "—"}</b> kills if you place <b>${placementLabel}</b>.`;
}

function updateTeam(forceSort){
  const { teamRank } = computeTeam();
  { const _el = document.getElementById("realPlayers"); if(_el) _el.textContent = String(realPlayers); }

  if(teamRank <= 0){
    document.getElementById("teamRank").textContent = "–";
    { const _el = document.getElementById("divisor"); if(_el) _el.textContent = "–"; }
    { const _el = document.getElementById("killsNeeded45"); if(_el) _el.textContent = "Select players to calculate"; }
    { const _el = document.getElementById("killsNeededTarget"); if(_el) _el.textContent = "—"; }
    updateReplacementHelper();
    recalc(forceSort);
    saveState();
    return;
  }

  document.getElementById("teamRank").textContent = teamRank.toFixed(2);
  { const _el = document.getElementById("divisor"); if(_el) _el.textContent = (teamRank*0.1).toFixed(2); }

  calcKillsNeededBlocks(teamRank);
  recalc(forceSort);
  updateReplacementHelper();
  saveState();
}



function createGameNode(g){
  const wrap = document.createElement("div");
  wrap.className = "gameRow";

  wrap.innerHTML = `
    <div class="colLabel">
      <label>${escapeHtml(g.label)}</label>
      <div class="muted" style="margin-top:4px;">${g.isReset ? "Optional reset map" : "Main map"}</div>
    </div>

    <div>
      <label>Kills</label>
      <input id="kills-${g.id}" type="number" min="0" step="1" placeholder="—" autocomplete="off" inputmode="numeric"/>
    </div>

    <div>
      <label>Placement</label>
      <select id="place-${g.id}">
        <option value="">—</option>
        <option value="1st">1st</option>
        <option value="2nd">2nd</option>
        <option value="3rd">3rd</option>
        <option value="4th">4th</option>
        <option value="5th">5th</option>
        <option value="6th+">6th+</option>
      </select>
    </div>

    <div class="colScore">
      <div class="scoreBig" id="score-${g.id}">0.00</div>
      <div class="scoreSub" id="scoreSub-${g.id}">—</div>
    </div>
  `;

  const kIn = wrap.querySelector(`#kills-${g.id}`);
  const pIn = wrap.querySelector(`#place-${g.id}`);

  const onChange = () => {
    g.killsStr = String(kIn.value ?? "").trim();
    g.killsInt = g.killsStr === "" ? 0 : Math.max(0, parseInt(g.killsStr, 10) || 0);
    g.placement = pIn.value || "";
    recalc(true);
    saveState();
  };

  kIn.addEventListener("input", onChange);
  pIn.addEventListener("change", onChange);

  // Load existing
  if(g.killsStr !== "") kIn.value = g.killsStr;
  pIn.value = g.placement || "";

  return wrap;
}

function recalc(updateTargets){
  // team rank
  const rankTxt = document.getElementById("teamRank")?.textContent || "–";
  const teamRank = parseFloat(rankTxt);
  const hasRank = (teamRank > 0);

  // compute each game score
  games.forEach(g => {
    let pts = 0;
    if(hasRank && g.placement && g.killsInt >= 0){
      pts = gamePointsFromKills(g.killsInt, g.placement, teamRank);
    }
    g.points = pts || 0;

    const scoreEl = document.getElementById(`score-${g.id}`);
    const subEl = document.getElementById(`scoreSub-${g.id}`);
    if(scoreEl) scoreEl.textContent = (g.points || 0).toFixed(2);

    if(subEl){
      if(!g.placement){
        subEl.textContent = "Select placement";
      }else if(!hasRank){
        subEl.textContent = "Select squad";
      }else{
        const placePts = placementPoints(g.placement);
        const ms = milestonePoints(g.killsInt);
        const div = (teamRank*0.1).toFixed(2);
        subEl.textContent = `${g.killsInt} kills + ${ms} ms + ${placePts} place ÷ ${div}`;
      }
    }
  });

  const main = games.filter(g => !g.isReset);
  const reset = games.find(g => g.isReset);

  const loggedMain = main.filter(g => g.placement && g.killsStr !== "").length;

  // totals: best 6 of the 6 main, with reset able to replace lowest of main if better
  let effectiveMain = [...main];

  if(reset && reset.placement && reset.killsStr !== ""){
    // replace lowest main score (even if not all filled; still useful)
    let li=-1, lv=Infinity;
    effectiveMain.forEach((g,i)=>{ if(g.points < lv){ lv=g.points; li=i; } });
    if(li>=0 && reset.points > lv){
      effectiveMain[li] = reset;
    }
  }

  // Count best 6 (which is all 6 slots after replacement)
  const total = effectiveMain.reduce((s,g)=>s+(g.points||0),0);

  const totalEl = document.getElementById("best4Total");
  if(totalEl) totalEl.textContent = total.toFixed(2);

  const enteredEl = document.getElementById("gamesEntered");
  if(enteredEl) enteredEl.textContent = String(loggedMain);

  if(updateTargets && hasRank){
    calcKillsNeededBlocks(teamRank);
  }else{
    const out = document.getElementById("killsNeeded45");
    if(out && !hasRank) out.textContent = "Select your squad to see remaining requirements.";
  }
}

async function boot(){
  // Always show the 7-map editor even if CSV fails
  try{
    await loadCSV();
  }catch(e){
    console.warn(e);
    const st = document.getElementById("csvStatus");
    if(st){ st.style.display='inline-flex'; st.textContent='Rankings CSV not loaded (check rankings.csv is in the same folder)'; }
    rankings = [{name:"NONE", rank:0}];
    rankByNameLower = new Map([["none", 0]]);
    const dl = document.getElementById("playersList");
    if(dl){
      dl.innerHTML = '<option value="NONE" label="NONE (0)"></option>';
    }
  }

  loadState();

  // Ensure fixed 7 maps layout (6 main + reset)
  if(!Array.isArray(games) || games.length !== 7){
    initGamesFixed();
  }else{
    // Normalize ids/labels/reset flag
    games = games.map((g,i)=>({
      id: (g && typeof g.id==='number') ? g.id : (i+1),
      label: (i<6 ? `Map ${i+1}` : 'Reset (Map 7)'),
      killsStr: (g && typeof g.killsStr==='string') ? g.killsStr : '',
      killsInt: (g && typeof g.killsInt==='number') ? g.killsInt : 0,
      placement: (g && typeof g.placement==='string') ? g.placement : '',
      points: (g && typeof g.points==='number') ? g.points : 0,
      isReset: (i===6)
    }));
  }

  hookInputs();
  updateTeam(true);
  renderGames();
  recalc(true);
}

window.addEventListener("DOMContentLoaded", boot);
</script>

</form>
</body>
</html>
